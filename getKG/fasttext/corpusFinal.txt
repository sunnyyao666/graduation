__label__访问控制修饰符 访问控制修饰符
__label__构造方法 __label__对象和类 __label__Java基础语法 __label__访问控制修饰符 Java 中 ， 可以 使用 访问控制符 来 保护 对类 、 变量 、 方法 和 构造方法 的 访问
__label__访问控制修饰符 Java   支持   4   种 不同 的 访问 权限
__label__Java包(package) __label__Java基础语法 __label__访问控制修饰符 default   ( 即 默认 ， 什么 也 不 写 ） :   在 同一 包内 可见 ， 不 使用 任何 修饰符
__label__Java基础语法 __label__访问控制修饰符 __label__Java多态 __label__Java接口 __label__Java方法 使用 对象 ： 类 、 接口 、 变量 、 方法
__label__访问控制修饰符 private   :   在 同 一类 内 可见
__label__Java方法 __label__Java基础语法 __label__访问控制修饰符 使用 对象 ： 变量 、 方法
__label__访问控制修饰符 注意 ： 不能 修饰 类 （ 外部类 ）
__label__访问控制修饰符 public   :   对 所有 类 可见
__label__Java基础语法 __label__访问控制修饰符 __label__Java多态 __label__Java接口 __label__Java方法 使用 对象 ： 类 、 接口 、 变量 、 方法
__label__Java包(package) __label__访问控制修饰符 protected   :   对 同一 包内 的 类 和 所有 子类 可见
__label__Java方法 __label__Java基础语法 __label__访问控制修饰符 使用 对象 ： 变量 、 方法
__label__访问控制修饰符 注意 ： 不能 修饰 类 （ 外部类 ）
__label__访问控制修饰符 我们 可以 通过 以下 表来 说明 访问 权限 ：
__label__Java包(package) __label__Java基础语法 __label__访问控制修饰符 修饰符   public   当前 类   Y   同一 包内   Y   子孙 类 ( 同一 包 )   Y   子孙 类 ( 不同 包 )   Y   其他 包   Y  
__label__Java包(package) __label__Java基础语法 __label__访问控制修饰符 修饰符   protected   当前 类   Y   同一 包内   Y   子孙 类 ( 同一 包 )   Y   子孙 类 ( 不同 包 )   Y / N （ 说明 ）   其他 包   N  
__label__Java包(package) __label__Java基础语法 __label__访问控制修饰符 修饰符   default   当前 类   Y   同一 包内   Y   子孙 类 ( 同一 包 )   Y   子孙 类 ( 不同 包 )   N   其他 包   N  
__label__Java包(package) __label__Java基础语法 __label__访问控制修饰符 修饰符   private   当前 类   Y   同一 包内   N   子孙 类 ( 同一 包 )   N   子孙 类 ( 不同 包 )   N   其他 包   N  
__label__Java包(package) __label__Java方法 __label__Java基础语法 __label__访问控制修饰符 使用 默认访问修饰符 声明 的 变量 和 方法 ， 对 同一个 包内 的 类 是 可见 的
__label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__Java接口 __label__Java方法 接口 里 的 变量 都 隐式 声明 为   public   static   final , 而 接口 里 的 方法 默认 情况 下 访问 权限 为   public
__label__Java基础语法 __label__访问控制修饰符 __label__构造方法 __label__Java接口 __label__Java多态 __label__对象和类 私有访问修饰符 是 最 严格 的 访问 级别 ， 所以 被 声明 为   private   的 方法 、 变量 和 构造方法 只能 被 所属 类 访问 ， 并且 类 和 接口 不能 声明 为   private
__label__Java方法 __label__Java基础语法 __label__访问控制修饰符 声明 为 私有 访问 类型 的 变量 只能 通过 类中 公共 的   getter   方法 被 外部类 访问
__label__Java基础语法 __label__访问控制修饰符 Private   访问修饰符 的 使用 主要 用来 隐藏 类 的 实现 细节 和 保护 类 的 数据
__label__访问控制修饰符 __label__构造方法 __label__Java多态 __label__Java接口 __label__对象和类 被 声明 为   public   的 类 、 方法 、 构造方法 和 接口 能够 被 任何 其他 类 访问
__label__Java包(package) __label__访问控制修饰符 如果 几个 相互 访问 的   public   类 分布 在 不同 的 包中 ， 则 需要 导入 相应   public   类 所在 的 包
__label__Java继承 __label__Java方法 __label__Java基础语法 __label__访问控制修饰符 由于 类 的 继承性 ， 类 所有 的 公有 方法 和 变量 都 能 被 其子 类 继承
__label__Java方法 __label__访问控制修饰符 Java   程序 的   main ( )   方法 必须 设置 成 公有 的 ， 否则 ， Java   解释器 将 不能 运行 该类
__label__访问控制修饰符 protected   需要 从 以下 两个 点来 分析 说明 ：
__label__Java基础语法 __label__访问控制修饰符 __label__Java继承 __label__Java方法 __label__Java包(package) 子类 与 基类 在 同一 包中 ： 被 声明 为   protected   的 变量 、 方法 和 构造器 能 被 同一个 包中 的 任何 其他 类 访问 ；
__label__Java继承 __label__Java包(package) __label__Java方法 __label__访问控制修饰符 子类 与 基类 不 在 同一 包中 ： 那么 在 子类 中 ， 子类 实例 可以 访问 其 从 基类 继承 而来 的   protected   方法 ， 而 不能 访问 基类 实例 的 protected 方法
__label__构造方法 __label__对象和类 __label__访问控制修饰符 protected   可以 修饰 数据 成员 ， 构造方法 ， 方法 成员 ， 不能 修饰 类 （ 内部 类 除外 ）
__label__Java基础语法 __label__访问控制修饰符 __label__Java多态 __label__Java接口 __label__Java方法 接口 及 接口 的 成员 变量 和 成员 方法 不能 声明 为   protected
__label__访问控制修饰符 可以 看看 下图 演示 ：
__label__Java方法 __label__Java基础语法 __label__访问控制修饰符 子类 能 访问   protected   修饰符 声明 的 方法 和 变量 ， 这样 就 能 保护 不 相关 的 类 使用 这些 方法 和 变量
__label__Java继承 __label__Java方法 __label__访问控制修饰符 请 注意 以下 方法 继承 的 规则 ：
__label__Java方法 __label__访问控制修饰符 父类 中 声明 为   public   的 方法 在 子类 中 也 必须 为   public
__label__Java方法 __label__访问控制修饰符 父类 中 声明 为   protected   的 方法 在 子类 中 要么 声明 为   protected ， 要么 声明 为   public ， 不能 声明 为   private
__label__Java继承 __label__Java方法 __label__访问控制修饰符 父类 中 声明 为   private   的 方法 ， 不 能够 被子 类 继承
__label__非访问修饰符 非访问修饰符
__label__非访问修饰符 为了 实现 一些 其他 的 功能 ， Java   也 提供 了 许多 非访问修饰符
__label__非访问修饰符 __label__类变量（静态变量） __label__Java方法 __label__Java基础语法 static   修饰符 ， 用来 修饰 类 方法 和 类变量
__label__Java基础语法 __label__非访问修饰符 __label__Java继承 __label__Java常量 __label__Java方法 final   修饰符 ， 用来 修饰 类 、 方法 和 变量 ， final   修饰 的 类 不 能够 被 继承 ， 修饰 的 方法 不能 被 继承 类 重新 定义 ， 修饰 的 变量 为 常量 ， 是 不可 修改 的
__label__非访问修饰符 __label__Java多态 __label__Java基础语法 __label__抽象类 abstract   修饰符 ， 用来 创建 抽象类 和 抽象方法
__label__非访问修饰符 __label__类变量（静态变量） __label__Java关键字 静态变量 ： static   关键字 用来 声明 独立 于 对象 的 静态变量 ， 无论 一个 类 实例 化 多少 对象 ， 它 的 静态变量 只有 一份 拷贝
__label__非访问修饰符 __label__类变量（静态变量） 静态变量 也 被 称为 类变量
__label__非访问修饰符 __label__Java局部变量 局部变量 不能 被 声明 为   static   变量
__label__非访问修饰符 __label__Java方法 __label__Java关键字 静态方法 ： static   关键字 用来 声明 独立 于 对象 的 静态方法
__label__非访问修饰符 __label__类变量（静态变量） __label__Java方法 静态方法 不能 使用 类 的 非 静态变量
__label__非访问修饰符 __label__Java方法 静态方法 从 参数 列表 得到 数据 ， 然后 计算 这些 数据
__label__非访问修饰符 __label__类变量（静态变量） __label__Java方法 对 类变量 和 方法 的 访问 可以 直接 使用   classname . variablename   和   classname . methodname   的 方式 访问
__label__非访问修饰符 __label__Java基础语法 __label__Java继承 final   变量 ：
__label__非访问修饰符 __label__Java基础语法 __label__Java继承 final   表示 " 最后 的 、 最终 的 " 含义 ， 变量 一旦 赋值 后 ， 不能 被 重新 赋值
__label__非访问修饰符 __label__实例变量 __label__Java继承 被   final   修饰 的 实例变量 必须 显式 指定 初始值
__label__非访问修饰符 __label__Java基础语法 __label__Java常量 __label__Java继承 final   修饰符 通常 和   static   修饰符 一起 使用 来 创建 类 常量
__label__非访问修饰符 __label__Java方法 __label__Java继承 final   方法
__label__非访问修饰符 __label__Java继承 __label__Java多态 __label__重写(Override) __label__Java方法 父类 中 的   final   方法 可以 被子 类 继承 ， 但是 不能 被子 类 重写
__label__非访问修饰符 __label__Java方法 __label__Java继承 声明   final   方法 的 主要 目的 是 防止 该 方法 的 内容 被 修改
__label__非访问修饰符 __label__Java基础语法 __label__Java方法 __label__Java继承 如下 所示 ， 使用   final   修饰符 声明 方法
__label__非访问修饰符 __label__Java继承 final   类
__label__非访问修饰符 __label__Java继承 final   类 不能 被 继承 ， 没有 类 能够 继承   final   类 的 任何 特性
__label__非访问修饰符 __label__Java多态 __label__抽象类 抽象类 ：
__label__非访问修饰符 __label__Java多态 __label__抽象类 抽象类 不能 用来 实例 化 对象 ， 声明 抽象类 的 唯一 目的 是 为了 将来 对 该类 进行 扩充
__label__非访问修饰符 __label__Java继承 一个 类 不能 同时 被   abstract   和   final   修饰
__label__非访问修饰符 __label__Java包(package) __label__Java多态 __label__抽象类 如果 一个 类 包含 抽象方法 ， 那么 该类 一定 要 声明 为 抽象类 ， 否则 将 出现 编译 错误
__label__非访问修饰符 __label__Java包(package) __label__Java多态 __label__抽象类 抽象类 可以 包含 抽象方法 和 非 抽象方法
__label__非访问修饰符 __label__Java多态 __label__抽象类 抽象方法
__label__非访问修饰符 __label__Java多态 __label__抽象类 抽象方法 是 一种 没有 任何 实现 的 方法 ， 该 方法 的 具体 实现 由 子类 提供
__label__非访问修饰符 __label__Java多态 __label__Java继承 __label__抽象类 抽象方法 不能 被 声明 成   final   和   static
__label__非访问修饰符 __label__Java多态 __label__Java继承 __label__抽象类 任何 继承 抽象类 的 子类 必须 实现 父类 的 所有 抽象方法 ， 除非 该 子类 也 是 抽象类
__label__非访问修饰符 __label__Java包(package) __label__Java多态 __label__抽象类 如果 一个 类 包含 若干个 抽象方法 ， 那么 该类 必须 声明 为 抽象类
__label__非访问修饰符 __label__Java包(package) __label__Java多态 __label__抽象类 抽象类 可以 不 包含 抽象方法
__label__Java局部变量 Java局部变量
__label__构造方法 __label__对象和类 __label__Java局部变量 局部变量 声明 在 方法 、 构造方法 或者 语句 块 中 ；
__label__构造方法 __label__对象和类 __label__Java局部变量 局部变量 在 方法 、 构造方法 、 或者 语句 块 被 执行 的 时候 创建 ， 当 它们 执行 完成 后 ， 变量 将会 被 销毁 ；
__label__Java基础语法 __label__Java局部变量 访问修饰符 不能 用于 局部变量 ；
__label__构造方法 __label__对象和类 __label__Java局部变量 局部变量 只 在 声明 它 的 方法 、 构造方法 或者 语句 块 中 可见 ；
__label__Java局部变量 局部变量 是 在 栈 上 分配 的
__label__Java局部变量 局部变量 没有 默认值 ， 所以 局部变量 被 声明 后 ， 必须 经过 初始化 ， 才 可以 使用
__label__实例变量 实例变量
__label__构造方法 __label__实例变量 __label__对象和类 实例变量 声明 在 一个 类中 ， 但 在 方法 、 构造方法 和 语句 块 之外 ；
__label__实例变量 当 一个 对象 被 实例 化 之后 ， 每个 实例变量 的 值 就 跟着 确定 ；
__label__实例变量 实例变量 在 对象 创建 的 时候 创建 ， 在 对象 被 销毁 的 时候 销毁 ；
__label__构造方法 __label__实例变量 __label__对象和类 实例变量 的 值 应该 至少 被 一个 方法 、 构造方法 或者 语句 块 引用 ， 使得 外部 能够 通过 这些 方式 获取 实例变量 信息 ；
__label__实例变量 实例变量 可以 声明 在 使用 前 或者 使用 后 ；
__label__实例变量 __label__Java基础语法 访问修饰符 可以 修饰 实例变量 ；
__label__构造方法 __label__实例变量 __label__对象和类 实例变量 对于 类中 的 方法 、 构造方法 或者 语句 块 是 可见 的
__label__实例变量 一般 情况 下 应该 把 实例变量 设 为 私有
__label__实例变量 __label__Java基础语法 通过 使用 访问修饰符 可以 使 实例变量 对子 类 可见 ；
__label__实例变量 实例变量 具有 默认值
__label__实例变量 __label__引用类型 __label__Java基础语法 数值 型 变量 的 默认值 是 0 ， 布尔 型 变量 的 默认值 是 false ， 引用类型 变量 的 默认值 是 null
__label__构造方法 __label__实例变量 __label__对象和类 __label__Java基础语法 变量 的 值 可以 在 声明 时 指定 ， 也 可以 在 构造方法 中 指定 ；
__label__实例变量 实例变量 可以 直接 通过 变量名 访问
__label__实例变量 __label__Java方法 但 在 静态方法 以及 其他 类中 ， 就 应该 使用 完全 限定 名 ： ObejectReference . VariableName
__label__类变量（静态变量） 类变量（静态变量）
__label__类变量（静态变量） __label__Java方法 __label__非访问修饰符 __label__Java关键字 类变量 也 称为 静态变量 ， 在 类 中以   static   关键字 声明 ， 但 必须 在 方法 之外
__label__类变量（静态变量） 无论 一个 类 创建 了 多少 个 对象 ， 类 只 拥有 类变量 的 一份 拷贝
__label__访问控制修饰符 __label__Java继承 __label__非访问修饰符 __label__Java常量 __label__类变量（静态变量） 静态变量 除了 被 声明 为 常量 外 很少 使用 ， 静态变量 是 指 声明 为   public / private ， final   和   static   类型 的 变量
__label__类变量（静态变量） 静态变量 初始化 后 不可 改变
__label__类变量（静态变量） 静态变量 储存 在 静态 存储 区
__label__类变量（静态变量） __label__Java基础语法 __label__Java常量 __label__非访问修饰符 经常 被 声明 为 常量 ， 很少 单独 使用   static   声明 变量
__label__类变量（静态变量） 静态变量 在 第一次 被 访问 时 创建 ， 在 程序 结束 时 销毁
__label__类变量（静态变量） __label__实例变量 与 实例变量 具有 相似 的 可见 性
__label__类变量（静态变量） __label__访问控制修饰符 但 为了 对类 的 使用者 可见 ， 大多数 静态变量 声明 为   public   类型
__label__类变量（静态变量） __label__实例变量 默认值 和 实例变量 相似
__label__类变量（静态变量） __label__内置数据类型 __label__引用类型 __label__Java基础语法 数值 型 变量 默认值 是   0 ， 布尔 型 默认值 是   false ， 引用 类型默认值 是   null
__label__类变量（静态变量） __label__构造方法 __label__对象和类 __label__Java基础语法 变量 的 值 可以 在 声明 的 时候 指定 ， 也 可以 在 构造方法 中 指定
__label__类变量（静态变量） 此外 ， 静态变量 还 可以 在 静态 语句 块 中 初始化
__label__类变量（静态变量） 静态变量 可以 通过 ： ClassName . VariableName 的 方式 访问
__label__类变量（静态变量） __label__Java继承 __label__非访问修饰符 __label__访问控制修饰符 类变量 被 声明 为   public   static   final   类型 时 ， 类变量 名称 一般 建议 使用 大写字母
__label__访问控制修饰符 __label__Java继承 __label__非访问修饰符 __label__类变量（静态变量） __label__实例变量 __label__Java局部变量 如果 静态变量 不是   public   和   final   类型 ， 其 命名 方式 与 实例变量 以及 局部变量 的 命名 方式 一致
__label__内置数据类型 内置数据类型
__label__内置数据类型 Java 语言 提供 了 八种 基本 类型
__label__内置数据类型 六种 数字 类型 （ 四个 整数型 ， 两个 浮点 型 ） ， 一种 字符 类型 ， 还有 一种 布尔 型
__label__内置数据类型 byte ：
__label__内置数据类型 byte   数据类型 是 8 位 、 有 符号 的 ， 以 二进制 补码 表示 的 整数 ；
__label__内置数据类型 最小值 是   - 128 （ - 2 ^ 7 ） ；
__label__内置数据类型 最大值 是   127 （ 2 ^ 7 - 1 ） ；
__label__内置数据类型 默认值 是   0 ；
__label__内置数据类型 __label__数组 __label__Java基础语法 byte   类型 用 在 大型 数组 中 节约 空间 ， 主要 代替 整数 ， 因为   byte   变量 占用 的 空间 只有   int   类型 的 四分之一 ；
__label__内置数据类型 例子 ： byte   a   =   100 ， byte   b   =   - 50
__label__内置数据类型 short ：
__label__内置数据类型 short   数据类型 是   16   位 、 有 符号 的 以 二进制 补码 表示 的 整数
__label__内置数据类型 最小值 是   - 32768 （ - 2 ^ 15 ） ；
__label__内置数据类型 最大值 是   32767 （ 2 ^ 15   -   1 ） ；
__label__内置数据类型 Short   数据类型 也 可以 像   byte   那样 节省 空间
__label__内置数据类型 __label__Java基础语法 一个 short 变量 是 int 型 变量 所 占 空间 的 二分之一 ；
__label__内置数据类型 默认值 是   0 ；
__label__内置数据类型 例子 ： short   s   =   1000 ， short   r   =   - 20000
__label__内置数据类型 int ：
__label__内置数据类型 int   数据类型 是 32 位 、 有 符号 的 以 二进制 补码 表示 的 整数 ；
__label__内置数据类型 最小值 是   - 2 , 147 , 483 , 648 （ - 2 ^ 31 ） ；
__label__内置数据类型 最大值 是   2 , 147 , 483 , 647 （ 2 ^ 31   -   1 ） ；
__label__内置数据类型 __label__Java基础语法 一般 地 整型 变量 默认 为   int   类型 ；
__label__内置数据类型 默认值 是   0   ；
__label__内置数据类型 例子 ： int   a   =   100000 ,   int   b   =   - 200000
__label__内置数据类型 long ：
__label__内置数据类型 long   数据类型 是   64   位 、 有 符号 的 以 二进制 补码 表示 的 整数 ；
__label__内置数据类型 最小值 是   - 9 , 223 , 372 , 036 , 854 , 775 , 808 （ - 2 ^ 63 ） ；
__label__内置数据类型 最大值 是   9 , 223 , 372 , 036 , 854 , 775 , 807 （ 2 ^ 63   - 1 ） ；
__label__内置数据类型 这种 类型 主要 使用 在 需要 比较 大 整数 的 系统 上 ；
__label__内置数据类型 默认值 是   0L ；
__label__内置数据类型 例子 ：   long   a   =   100000L ， Long   b   =   - 200000L
__label__内置数据类型 " L " 理论 上不分 大小写 ， 但是 若 写成 " l " 容易 与 数字 " 1 " 混淆 ， 不 容易 分辩
__label__内置数据类型 所以 最好 大写
__label__内置数据类型 float ：
__label__内置数据类型 float   数据类型 是 单精度 、 32 位 、 符合 IEEE   754 标准 的 浮点数 ；
__label__内置数据类型 __label__数组 __label__Java基础语法 float   在 储存 大型 浮点 数组 的 时候 可 节省 内存空间 ；
__label__内置数据类型 默认值 是   0.0 f ；
__label__内置数据类型 浮点数 不能 用来 表示 精确 的 值 ， 如 货币 ；
__label__内置数据类型 例子 ： float   f1   =   234.5 f
__label__内置数据类型 double ：
__label__内置数据类型 double   数据类型 是 双 精度 、 64   位 、 符合   IEEE   754   标准 的 浮点数 ；
__label__内置数据类型 浮点数 的 默认 类型 为   double   类型 ；
__label__内置数据类型 double 类型 同样 不能 表示 精确 的 值 ， 如 货币 ；
__label__内置数据类型 默认值 是   0.0 d ；
__label__内置数据类型 7   是 一个   int   字面 量 ， 而   7D ， 7 .   和   8.0   是   double   字面 量
__label__内置数据类型 boolean ：
__label__内置数据类型 boolean 数据类型 表示 一位 的 信息 ；
__label__内置数据类型 只有 两个 取值 ： true   和   false ；
__label__内置数据类型 这种 类型 只 作为 一种 标志 来 记录   true / false   情况 ；
__label__内置数据类型 默认值 是   false ；
__label__内置数据类型 例子 ： boolean   one   =   true
__label__内置数据类型 char ：
__label__内置数据类型 char   类型 是 一个 单一 的   16   位   Unicode   字符 ；
__label__内置数据类型 最小值 是   \ u0000 （ 十进制 等效值 为   0 ） ；
__label__内置数据类型 最大值 是   \ uffff （ 即 为   65535 ） ；
__label__内置数据类型 char   数据类型 可以 储存 任何 字符 ；
__label__内置数据类型 例子 ： char   letter   =   ' A ' ;
__label__内置数据类型 下 表列出 了   Java   各个 类型 的 默认值 ：
__label__内置数据类型 数据类型   byte   默认值   0  
__label__内置数据类型 数据类型   short   默认值   0  
__label__内置数据类型 数据类型   int   默认值   0  
__label__内置数据类型 数据类型   long   默认值   0L  
__label__内置数据类型 数据类型   float   默认值   0.0 f  
__label__内置数据类型 数据类型   double   默认值   0.0 d  
__label__内置数据类型 数据类型   char   默认值   ' u0000 '  
__label__内置数据类型 数据类型   String   ( or   any   object )   默认值   null  
__label__内置数据类型 数据类型   boolean   默认值   false  
__label__引用类型 引用类型
__label__引用类型 __label__Java基础语法 在 Java 中 ， 引用类型 的 变量 非常 类似 于 C / C++ 的 指针
__label__引用类型 __label__Java基础语法 引用类型 指向 一个 对象 ， 指向 对象 的 变量 是 引用 变量
__label__引用类型 __label__Java基础语法 这些 变量 在 声明 时 被 指定 为 一个 特定 的 类型 ， 比如   Employee 、 Puppy   等
__label__引用类型 __label__Java基础语法 变量 一旦 声明 后 ， 类型 就 不能 被 改变 了
__label__数组 __label__引用类型 __label__Java基础语法 对象 、 数组 都 是 引用 数据类型
__label__引用类型 所有 引用类型 的 默认值 都 是 null
__label__引用类型 __label__Java基础语法 一个 引用 变量 可以 用来 引用 任何 与 之 兼容 的 类型
__label__引用类型 例子 ： Site   site   =   new   Site ( " Java KG " )
__label__Java常量 Java常量
__label__Java常量 常量 在 程序运行 时 是 不能 被 修改 的
__label__Java基础语法 __label__非访问修饰符 __label__Java继承 __label__Java常量 __label__Java关键字 在   Java   中 使用   final   关键字 来 修饰 常量 ， 声明 方式 和 变量 类似 ：
__label__Java常量 虽然 常量 名 也 可以 用 小写 ， 但 为了 便于 识别 ， 通常 使用 大写字母 表示 常量
__label__Java常量 __label__Java基础语法 字面 量 可以 赋给 任何 内置 类型 的 变量
__label__Java常量 byte 、 int 、 long 、 和 short 都 可以 用 十进制 、 16 进制 以及 8 进制 的 方式 来 表示
__label__Java常量 当 使用 字面 量 的 时候 ， 前缀   0   表示   8   进制 ， 而 前缀   0x   代表   16   进制 ,   例如 ：
__label__Java包(package) __label__Java常量 和 其他 语言 一样 ， Java 的 字符串 常量 也 是 包含 在 两个 引号 之间 的 字符 序列
__label__Java常量 下面 是 字符串 型 字面 量 的 例子 ：
__label__Java包(package) __label__Java常量 __label__Java基础语法 字符串 常量 和 字符 变量 都 可以 包含 任何   Unicode   字符
__label__Java常量 Java 语言 支持 一些 特殊 的 转义字符 序列
__label__Java常量 符号   \n   字符 含义   换行   ( 0x0a )
__label__Java常量 符号   \r   字符 含义   回车   ( 0x0d )
__label__Java常量 符号   \f   字符 含义   换页 符 ( 0x0c )
__label__Java常量 符号   \b   字符 含义   退格   ( 0x08 )
__label__Java常量 符号   \0   字符 含义   空字符   ( 0x0 )
__label__Java常量 符号   \s   字符 含义   空格   ( 0x20 )
__label__Java常量 符号   \t   字符 含义   制表符
__label__Java常量 符号   \"   字符 含义   双引号
__label__Java常量 符号   \'   字符 含义   单引号
__label__Java常量 符号   \\   字符 含义   反 斜杠
__label__Java常量 符号   \ddd   字符 含义   八进制 字符   ( ddd )
__label__Java常量 符号   \uxxxx   字符 含义   16 进制 Unicode 字符   ( xxxx )
__label__自动类型转换 自动类型转换
__label__Java常量 __label__自动类型转换 整型 、 实型 （ 常量 ） 、 字符 型 数据 可以 混合 运算
__label__自动类型转换 运算 中 ， 不同 类型 的 数据 先 转化 为 同一 类型 ， 然后 进行 运算
__label__自动类型转换 转换 从 低级 到 高级
__label__自动类型转换 数据 类型转换 必须 满足 如下 规则 ：
__label__自动类型转换 1 .   不能 对 boolean 类型 进行 类型转换
__label__自动类型转换 2 .   不能 把 对象 类型转换 成 不 相关 类 的 对象
__label__自动类型转换 3 .   在 把 容量 大 的 类型转换 为 容量 小 的 类型 时 必须 使用 强制类型转换
__label__自动类型转换 4 .   转换 过程 中 可能 导致 溢出 或 损失 精度
__label__自动类型转换 因为   byte   类型 是   8   位 ， 最大值 为 127 ， 所以 当   int   强制 转换 为   byte   类型 时 ， 值   128   时候 就 会 导致 溢出
__label__自动类型转换 5 .   浮点数 到 整数 的 转换 是 通过 舍弃 小数 得到 ， 而 不是 四舍五入
__label__自动类型转换 1 .   条件 是 转换 的 数据类型 必须 是 兼容 的
__label__自动类型转换 2 .   格式 ： ( type ) value     type 是 要 强制类型转换 后 的 数据类型
__label__自动类型转换 1 、   整数 的 默认 类型 是   int
__label__自动类型转换 2 .   小数 默认 是   double   类型 浮点 型 ， 在 定义   float   类型 时 必须 在 数字 后面 跟上   F   或者   f
__label__Java基础语法 Java基础语法
__label__Java基础语法 编写   Java   程序 时 ， 应 注意 以下几点 ：
__label__Java基础语法 大小写 敏感 ： Java   是 大小写 敏感 的 ， 这 就 意味着 标识符   Hello   与   hello   是 不同 的
__label__Java基础语法 类名 ： 对于 所有 的 类 来说 ， 类名 的 首字母 应该 大写
__label__Java基础语法 如果 类名 由 若干 单词 组成 ， 那么 每个 单词 的 首字母 应该 大写 ， 例如   MyFirst Java Class
__label__Java方法 __label__Java基础语法 方法 名 ： 所有 的 方法 名 都 应该 以 小写字母 开头
__label__Java方法 __label__Java基础语法 如果 方法 名 含有 若干 单词 ， 则 后面 的 每个 单词 首字母 大写
__label__Java基础语法 源 文件名 ： 源 文件名 必须 和 类名 相同
__label__Java基础语法 当 保存 文件 的 时候 ， 你 应该 使用 类名 作为 文件名 保存 （ 切记   Java   是 大小写 敏感 的 ） ， 文件名 的 后缀 为   . java
__label__Java基础语法 （ 如果 文件名 和 类名 不 相同 则 会 导致 编译 错误 ）
__label__非访问修饰符 __label__Java方法 __label__Java基础语法 __label__访问控制修饰符 主 方法 入口 ： 所有 的   Java   程序 由   public   static   void   main ( String [ ]   args )   方法 开始 执行
__label__Java基础语法 Java   所有 的 组成部分 都 需要 名字
__label__Java方法 __label__Java基础语法 类名 、 变量名 以及 方法 名 都 被 称为 标识符
__label__Java基础语法 关于   Java   标识符 ， 有 以下几点 需要 注意 ：
__label__Java基础语法 所有 的 标识符 都 应该 以 字母 （ A - Z   或者   a - z ） , 美元 符 （ $ ） 、 或者 下划线 （ _ ） 开始
__label__Java基础语法 首 字符 之后 可以 是 字母 （ A - Z   或者   a - z ） , 美元 符 （ $ ） 、 下划线 （ _ ） 或 数字 的 任何 字符 组合
__label__Java基础语法 __label__Java关键字 关键字 不能 用作 标识符
__label__Java基础语法 标识符 是 大小写 敏感 的
__label__Java基础语法 合法 标识符 举例 ： age 、 $ salary 、 _ value 、 __ 1 _ value
__label__Java基础语法 非法 标识符 举例 ： 123abc 、 - salary
__label__Java方法 __label__Java基础语法 像 其他 语言 一样 ， Java 可以 使用 修饰符 来 修饰 类中 方法 和 属性
__label__Java基础语法 主要 有 两类 修饰符 ：
__label__Java基础语法 __label__访问控制修饰符 访问控制修饰符   :   default ,   public   ,   protected ,   private
__label__非访问修饰符 __label__Java继承 __label__Java基础语法 __label__访问控制修饰符 非访问控制修饰符   :   final ,   abstract ,   static ,   synchronized
__label__Java基础语法 Java   中 主要 有 如下 几种 类型 的 变量
__label__Java基础语法 __label__Java局部变量 局部变量
__label__类变量（静态变量） __label__Java基础语法 类变量 （ 静态变量 ）
__label__类变量（静态变量） __label__Java基础语法 成员 变量 （ 非 静态变量 ）
__label__数组 __label__Java基础语法 数组 是 储存 在 堆 上 的 对象 ， 可以 保存 多个 同 类型 变量
__label__数组 __label__Java基础语法 之后 将会 学到 如何 声明 、 构造 以及 初始化 一个 数组
__label__Java基础语法 如下 图 所示 ：
__label__Java关键字 Java关键字
__label__Java关键字 下面 列出 了   Java   关键字
__label__Java常量 __label__Java基础语法 __label__Java关键字 这些 保留字 不能 用于 常量 、 变量 、 和 任何 标识符 的 名称
__label__访问控制修饰符 __label__Java关键字 类别   访问控制   关键字   private   说明   私有 的  
__label__访问控制修饰符 __label__Java关键字 类别   protected   关键字   受 保护 的  
__label__访问控制修饰符 __label__Java关键字 类别   public   关键字   公共 的  
__label__Java关键字 类别   default   关键字   默认  
__label__非访问修饰符 __label__Java方法 __label__Java基础语法 __label__Java关键字 类别   类 、 方法 和 变量 修饰符   关键字   abstract   说明   声明 抽象  
__label__Java关键字 类别   class   关键字   类  
__label__Java继承 __label__Java关键字 类别   extends   关键字   扩充 , 继承  
__label__非访问修饰符 __label__Java继承 __label__Java关键字 类别   final   关键字   最终 值 , 不可 改变 的  
__label__Java多态 __label__Java接口 __label__Java关键字 类别   implements   关键字   实现 （ 接口 ）  
__label__Java多态 __label__Java接口 __label__Java关键字 类别   interface   关键字   接口  
__label__Java方法 __label__Java关键字 类别   native   关键字   本地 ， 原生 方法 （ 非   Java   实现 ）  
__label__Java关键字 类别   new   关键字   新 , 创建  
__label__非访问修饰符 __label__Java关键字 类别   static   关键字   静态  
__label__Java关键字 类别   strictfp   关键字   严格 , 精准  
__label__Java关键字 类别   synchronized   关键字   线程 , 同步  
__label__Java关键字 类别   transient   关键字   短暂  
__label__Java关键字 类别   volatile   关键字   易失  
__label__Java关键字 类别   程序控制 语句   关键字   break   说明   跳出 循环  
__label__switch-case语句 __label__Java关键字 类别   case   关键字   定义 一个 值以 供   switch   选择  
__label__Java关键字 类别   continue   关键字   继续  
__label__Java关键字 类别   default   关键字   默认  
__label__Java关键字 类别   do   关键字   运行  
__label__if-else语句 __label__Java关键字 类别   else   关键字   否则  
__label__Java关键字 类别   for   关键字   循环  
__label__if-else语句 __label__Java关键字 类别   if   关键字   如果  
__label__Java关键字 类别   instanceof   关键字   实例  
__label__Java关键字 类别   return   关键字   返回  
__label__switch-case语句 __label__Java关键字 类别   switch   关键字   根据 值 选择 执行  
__label__Java关键字 类别   while   关键字   循环  
__label__Java关键字 类别   错误处理   关键字   assert   说明   断言 表达式 是否 为 真  
__label__Java异常 __label__Java关键字 类别   catch   关键字   捕捉 异常  
__label__Java异常 __label__捕获异常 __label__Java关键字 类别   finally   关键字   有没有 异常 都 执行  
__label__Java异常 __label__捕获异常 __label__Java关键字 类别   throw   关键字   抛出 一个 异常 对象  
__label__Java异常 __label__捕获异常 __label__Java关键字 类别   throws   关键字   声明 一个 异常 可能 被 抛出  
__label__捕获异常 __label__Java关键字 类别   try   关键字   捕获异常  
__label__Java包(package) __label__Java关键字 类别   包 相关   关键字   import   说明   引入  
__label__Java包(package) __label__Java关键字 类别   package   关键字   包  
__label__Java关键字 类别   基本 类型   关键字   boolean   说明   布尔 型  
__label__Java关键字 类别   byte   关键字   字节 型  
__label__Java关键字 类别   char   关键字   字符 型  
__label__Java关键字 类别   double   关键字   双 精度 浮点  
__label__Java关键字 类别   float   关键字   单精度 浮点  
__label__Java关键字 类别   int   关键字   整型  
__label__Java关键字 类别   long   关键字   长 整型  
__label__Java关键字 类别   short   关键字   短 整型  
__label__Java继承 __label__重写(Override) __label__Java基础语法 __label__Java关键字 类别   变量 引用   关键字   super   说明   父类 , 超类  
__label__Java继承 __label__Java关键字 类别   this   关键字   本 类  
__label__Java关键字 类别   void   关键字   无 返回值  
__label__Java关键字 类别   保留 关键字   关键字   goto   说明   是 关键字 ， 但 不能 使用  
__label__Java关键字 类别   const   关键字   是 关键字 ， 但 不能 使用  
__label__Java常量 __label__Java基础语法 __label__Java关键字 注意 ： Java   的   null   不是 关键字 ， 类似 于   true   和   false ， 它 是 一个 字面 常量 ， 不 允许 作为 标识符 使用
__label__Character类 Character类
__label__Character类 Character   类 用于 对 单个 字符 进行 操作
__label__Java包(package) __label__Character类 Character   类 在 对象 中 包装 一个 基本 类型   char   的 值
__label__内置数据类型 __label__Character类 然而 ， 在 实际 开发 过程 中 ， 我们 经常 会 遇到 需要 使用 对象 ， 而 不是 内置数据类型 的 情况
__label__Java包(package) __label__内置数据类型 __label__Character类 为了 解决 这个 问题 ， Java 语言 为 内置数据类型 char 提供 了 包装 类 Character 类
__label__Java方法 __label__Character类 Character 类 提供 了 一系列 方法 来 操纵 字符
__label__构造方法 __label__对象和类 __label__Character类 你 可以 使用 Character 的 构造方法 创建 一个 Character 类 对象 ， 例如 ：
__label__Character类 在 某些 情况 下 ， Java 编译器 会 自动 创建 一个 Character 对象
__label__Character类 前面 有 反 斜杠 （ \ ） 的 字符 代表 转义字符 ， 它 对 编译器 来说 是 有 特殊 含义 的
__label__Character类 下面 列表 展示 了 Java 的 转义序列 ：
__label__Character类 转义序列   \t   描述   在 文中 该处 插入 一个 tab 键
__label__Character类 转义序列   \b   描述   在 文中 该处 插入 一个 后退 键
__label__Character类 转义序列   \n   描述   在 文中 该处 换行
__label__Character类 转义序列   \r   描述   在 文中 该处 插入 回车
__label__Character类 转义序列   \f   描述   在 文中 该处 插入 换页 符
__label__Character类 转义序列   \'   描述   在 文中 该处 插入 单引号
__label__Character类 转义序列   \"   描述   在 文中 该处 插入 双引号
__label__Character类 转义序列   \\   描述   在 文中 该处 插入 反 斜杠
__label__String类 String类
__label__String类 字符串 广泛应用   在   Java   编程 中 ， 在   Java   中 字符串 属于 对象 ， Java   提供 了   String   类来 创建 和 操作 字符串
__label__String类 创建字符串 最 简单 的 方式 如下 :
__label__String类 __label__Java常量 在 代码 中 遇到 字符串 常量 时 ， 这里 的 值 是   " Java KG " ， 编译器 会 使用 该值 创建 一个   String   对象
__label__String类 __label__构造方法 __label__对象和类 __label__Java关键字 和 其它 对象 一样 ， 可以 使用 关键字 和 构造方法 来 创建   String   对象
__label__String类 用 构造函数 创建字符串 ：
__label__String类 __label__Java方法 用于 获取 有关 对象 的 信息 的 方法 称为 访问 器 方法
__label__String类 __label__Java包(package) __label__Java方法 String   类 的 一个 访问 器 方法 是   length ( )   方法 ， 它 返回 字符串 对象 包含 的 字符 数
__label__String类 __label__Java方法 String   类 提供 了 连接 两个 字符串 的 方法 ：
__label__String类 返回   string2   连接   string1   的 新 字符串
__label__Java方法 __label__String类 __label__Java常量 也 可以 对 字符串 常量 使用   concat ( )   方法 ， 如 ：
__label__String类 更 常用 的 是 使用 ' + ' 操作符 来 连接字符串 ， 如 ：
__label__String类 结果 如下 :
__label__Java异常 Java异常
__label__Java异常 异常 是 程序 中 的 一些 错误 ， 但 并 不是 所有 的 错误 都 是 异常 ， 并且 错误 有时候 是 可以 避免 的
__label__Java异常 比如说 ， 你 的 代码 少 了 一个 分 号 ， 那么 运行 出来 结果 是 提示 是 错误   java . lang . Error ； 如果 你 用 System . out . println ( 11 / 0 ) ， 那么 你 是因为 你 用 0 做 了 除数 ， 会 抛出   java . lang . ArithmeticException   的 异常
__label__Java异常 __label__Java包(package) 异常 发生 的 原因 有 很多 ， 通常 包含 以下 几大类 ：
__label__Java异常 用户 输入 了 非法 数据
__label__Java异常 要 打开 的 文件 不 存在
__label__Java异常 网络通信 时 连接 中断 ， 或者 JVM 内存 溢出
__label__Java异常 这些 异常 有的是 因为 用户 错误 引起 ， 有的是 程序 错误 引起 的 ， 还有 其它 一些 是因为 物理 错误 引起 的
__label__Java异常 -
__label__Java异常 要 理解 Java 异常 处理 是 如何 工作 的 ， 你 需要 掌握 以下 三种 类型 的 异常 ：
__label__Java异常 检查 性 异常 ： 最具 代表 的 检查 性 异常 是 用户 错误 或 问题 引起 的 异常 ， 这是 程序员 无法 预见 的
__label__Java异常 例如 要 打开 一个 不 存在 文件 时 ， 一个 异常 就 发生 了 ， 这些 异常 在 编译 时 不能 被 简单 地 忽略
__label__Java异常 运行 时 异常 ：   运行 时 异常 是 可能 被 程序员 避免 的 异常
__label__Java异常 与 检查 性 异常 相反 ， 运行 时 异常 可以 在 编译 时 被 忽略
__label__Java异常 错误 ：   错误 不是 异常 ， 而是 脱离 程序员 控制 的 问题
__label__Java异常 错误 在 代码 中 通常 被 忽略
__label__Java异常 例如 ， 当栈 溢出 时 ， 一个 错误 就 发生 了 ， 它们 在 编译 也 检查 不到 的
__label__Java继承 __label__Java异常 所有 的 异常 类 是从   java . lang . Exception   类 继承 的 子类
__label__Java异常 Exception   类 是   Throwable   类 的 子类
__label__Java异常 除了 Exception 类外 ， Throwable 还有 一个 子类 Error
__label__Java异常 Java   程序 通常 不 捕获 错误
__label__Java异常 错误 一般 发生 在 严重 故障 时 ， 它们 在 Java 程序处理 的 范畴 之外
__label__Java异常 Error   用来 指示 运行 时 环境 发生 的 错误
__label__Java异常 例如 ， JVM   内存 溢出
__label__Java异常 一般 地 ， 程序 不会 从 错误 中 恢复
__label__Java异常 异常 类有 两个 主要 的 子类 ： IOException   类 和   RuntimeException   类
__label__Java异常 __label__Java方法 下面 的 列表 是   Throwable   类 的 主要 方法 :
__label__Java异常 __label__Java方法 __label__访问控制修饰符 序号   1   方法 及 说明   public   String   getMessage ( ) 	 	 	 	 返回 关于 发生 的 异常 的 详细信息 。 这个 消息 在 Throwable   类 的 构造函数 中 初始化 了 。  
__label__Java异常 __label__Java方法 __label__访问控制修饰符 序号   2   方法 及 说明   public   Throwable   getCause ( ) 	 	 	 	 返回 一个   Throwable   对象 代表 异常 原因 。  
__label__Java异常 __label__Java方法 __label__访问控制修饰符 序号   3   方法 及 说明   public   String   to String ( ) 	 	 	 	 返回 此   Throwable   的 简短 描述 。  
__label__Java异常 __label__Java方法 __label__访问控制修饰符 序号   4   方法 及 说明   public   void   printStackTrace ( ) 	 	 	 	 将 此   Throwable   及其 回溯 打印 到 标准 错误 流 。 。  
__label__Java基础语法 __label__访问控制修饰符 __label__数组 __label__Java包(package) __label__Java方法 __label__Java异常 序号   5   方法 及 说明   public   StackTraceElement   [ ]   getStackTrace ( ) 	 	 	 	 返回 一个 包含 堆栈 层次 的 数组 。 下标 为 0 的 元素 代表 栈顶 ， 最后 一个 元素 代表 方法调用 堆栈 的 栈底 。  
__label__Java异常 __label__Java方法 __label__访问控制修饰符 序号   6   方法 及 说明   public   Throwable   fillInStackTrace ( ) 	 	 	 	 用 当前 的 调用 栈 层次 填充 Throwable   对象 栈 层次 ， 添加 到 栈 层次 任何 先前 信息 中 。  
__label__Java异常 在 Java 中 定义 了 两种 类型 的 异常 和 错误
__label__Java异常 JVM ( Java 虚拟机 )   异常 ： 由   JVM   抛出 的 异常 或 错误
__label__Java异常 程序 级 异常 ： 由 程序 或者 API 程序 抛出 的 异常
__label__Java异常 例如   IllegalArgumentException   类 ， IllegalStateException   类
__label__捕获异常 捕获异常
__label__Java关键字 __label__捕获异常 使用   try   和   catch   关键字 可以 捕获异常
__label__Java异常 __label__捕获异常 try / catch   代码 块 放在 异常 可能 发生 的 地方
__label__捕获异常 try / catch 代码 块 中 的 代码 称为 保护 代码 ， 使用   try / catch   的 语法 如下 ：
__label__Java包(package) __label__捕获异常 Catch   语句 包含 要 捕获异常 类型 的 声明
__label__Java异常 __label__捕获异常 当 保护 代码 块 中 发生 一个 异常 时 ， try   后面 的   catch   块 就 会 被 检查
__label__Java方法 __label__Java异常 __label__Java包(package) __label__捕获异常 如果 发生 的 异常 包含 在   catch   块 中 ， 异常 会 被 传递 到 该   catch   块 ， 这 和 传递 一个 参数 到 方法 是 一样
__label__捕获异常 一个   try   代码 块 后面 跟随 多个   catch   代码 块 的 情况 就 叫 多重 捕获
__label__捕获异常 多重捕获块 的 语法 如下 所示 ：
__label__Java包(package) __label__捕获异常 上面 的 代码段 包含 了   3   个   catch 块
__label__捕获异常 可以 在   try   语句 后面 添加 任意 数量 的   catch   块
__label__Java异常 __label__捕获异常 如果 保护 代码 中 发生 异常 ， 异常 被 抛 给 第一个   catch   块
__label__Java异常 __label__捕获异常 如果 抛出 异常 的 数据类型 与   ExceptionType1   匹配 ， 它 在 这里 就 会 被 捕获
__label__捕获异常 如果 不 匹配 ， 它会 被 传递 给 第二个   catch   块
__label__Java异常 __label__捕获异常 如此 ， 直到 异常 被 捕获 或者 通过 所有 的   catch   块
__label__Java关键字 __label__Java异常 __label__Java方法 __label__捕获异常 如果 一个 方法 没有 捕获 到 一个 检查 性 异常 ， 那么 该 方法 必须 使用   throws   关键字 来 声明
__label__Java关键字 __label__Java方法 __label__捕获异常 throws   关键字 放在 方法 签名 的 尾部
__label__Java关键字 __label__Java异常 __label__捕获异常 也 可以 使用   throw   关键字 抛出 一个 异常 ， 无论 它 是 新 实例 化 的 还是 刚 捕获 到 的
__label__Java异常 __label__Java方法 __label__捕获异常 下面 方法 的 声明 抛出 一个   RemoteException   异常 ：
__label__Java异常 __label__Java方法 __label__捕获异常 一个 方法 可以 声明 抛出 多个 异常 ， 多个 异常 之间 用 逗号 隔开
__label__Java方法 __label__捕获异常 例如 ， 下面 的 方法 声明 抛出   RemoteException   和   InsufficientFundsException ：
__label__Java关键字 __label__捕获异常 finally   关键字 用来 创建 在   try   代码 块 后面 执行 的 代码 块
__label__Java异常 __label__捕获异常 无论 是否 发生 异常 ， finally   代码 块 中 的 代码 总会 被 执行
__label__捕获异常 在   finally   代码 块 中 ， 可以 运行 清理 类型 等 收尾 善后 性质 的 语句
__label__捕获异常 finally   代码 块 出现 在   catch   代码 块 最后 ， 语法 如下 ：
__label__捕获异常 注意 下面 事项 ：
__label__捕获异常 catch   不能 独立 于   try   存在
__label__捕获异常 在   try / catch   后面 添加   finally   块 并非 强制性 要求 的
__label__捕获异常 try   代码 后 不能 既 没   catch   块 也 没   finally   块
__label__捕获异常 try ,   catch ,   finally   块 之间 不能 添加 任何 代码
__label__自定义异常 自定义异常
__label__自定义异常 在   Java   中 你 可以 自定义异常
__label__自定义异常 __label__Java异常 编写 自己 的 异常 类时 需要 记住 下面 的 几点
__label__自定义异常 __label__Java异常 所有 异常 都 必须 是   Throwable   的 子类
__label__自定义异常 __label__Java异常 __label__Java继承 如果 希望 写 一个 检查 性 异常 类 ， 则 需要 继承   Exception   类
__label__自定义异常 __label__Java异常 __label__Java继承 如果 你 想 写 一个 运行 时 异常 类 ， 那么 需要 继承   RuntimeException   类
__label__自定义异常 __label__Java异常 可以 像 下面 这样 定义 自己 的 异常 类 ：
__label__自定义异常 __label__Java异常 __label__Java继承 只 继承 Exception   类来 创建 的 异常 类 是 检查 性 异常 类
__label__Java基础语法 __label__自定义异常 __label__Java包(package) __label__Java方法 __label__Java异常 一个 异常 类 和 其它 任何 类 一样 ， 包含 有 变量 和 方法
__label__while循环 while循环
__label__while循环 while 是 最 基本 的 循环 ， 它 的 结构 为 ：
__label__while循环 只要 布尔 表达式 为   true ， 循环 就 会 一直 执行 下去
__label__do…while循环 do…while循环
__label__do…while循环 对于   while   语句 而言 ， 如果 不 满足条件 ， 则 不能 进入 循环
__label__do…while循环 但 有时候 我们 需要 即使 不 满足条件 ， 也 至少 执行 一次
__label__do…while循环 do … while   循环 和   while   循环 相似 ， 不同 的 是 ， do … while   循环 至少 会 执行 一次
__label__do…while循环 注意 ： 布尔 表达式 在 循环体 的 后面 ， 所以 语句 块 在 检测 布尔 表达式 之前 已经 执行 了
__label__do…while循环 如果 布尔 表达式 的 值 为   true ， 则 语句 块 一直 执行 ， 直到 布尔 表达式 的 值 为   false
__label__for循环 for循环
__label__for循环 虽然 所有 循环 结构 都 可以 用   while   或者   do ... while 表示 ， 但   Java   提供 了 另 一种 语句   — —   for   循环 ， 使 一些 循环 结构 变得 更加 简单
__label__for循环 for 循环 执行 的 次数 是 在 执行 前 就 确定 的
__label__for循环 语法 格式 如下 ：
__label__for循环 关于   for   循环 有 以下几点 说明 ：
__label__for循环 最先 执行 初始化 步骤
__label__for循环 __label__Java基础语法 可以 声明 一种 类型 ， 但 可 初始化 一个 或 多个 循环 控制变量 ， 也 可以 是 空语句
__label__for循环 然后 ， 检测 布尔 表达式 的 值
__label__for循环 如果 为   true ， 循环体 被 执行
__label__for循环 如果 为 false ， 循环 终止 ， 开始 执行 循环体 后面 的 语句
__label__for循环 __label__Java基础语法 执行 一次 循环 后 ， 更新 循环 控制变量
__label__for循环 再次 检测 布尔 表达式
__label__for循环 循环 执行 上面 的 过程
__label__foreach循环 foreach循环
__label__数组 __label__Java基础语法 __label__foreach循环 Java 5   引入 了 一种 主要 用于 数组 的 增强型   for   循环
__label__foreach循环 Java   增强   for   循环 语法 格式 如下 :
__label__Java局部变量 __label__数组 __label__Java基础语法 __label__foreach循环 声明 语句 ： 声明 新 的 局部变量 ， 该 变量 的 类型 必须 和 数组 元素 的 类型 匹配
__label__数组 __label__Java基础语法 __label__foreach循环 其 作用域 限定 在 循环 语句 块 ， 其值 与 此时 数组 元素 的 值 相等
__label__Java方法 __label__数组 __label__Java基础语法 __label__foreach循环 表达式 ： 表达式 是 要 访问 的 数组名 ， 或者 是 返回值 为 数组 的 方法
__label__break关键字 break关键字
__label__break关键字 __label__switch-case语句 break   主要 用 在 循环 语句 或者   switch   语句 中 ， 用来 跳出 整个 语句 块
__label__break关键字 break   跳出 最里层 的 循环 ， 并且 继续执行 该 循环 下面 的 语句
__label__break关键字 break   的 用法 很 简单 ， 就是 循环 结构 中 的 一条 语句 ：
__label__continue关键字 continue关键字
__label__continue关键字 continue   适用 于 任何 循环 控制结构 中
__label__continue关键字 作用 是 让 程序 立刻 跳转 到 下 一次 循环 的 迭代
__label__continue关键字 在   for   循环 中 ， continue   语句 使 程序 立即 跳转 到 更新 语句
__label__continue关键字 在   while   或者   do … while   循环 中 ， 程序 立即 跳转 到 布尔 表达式 的 判断 语句
__label__continue关键字 continue   就是 循环体 中 一条 简单 的 语句 ：
__label__ArrayList ArrayList
__label__ArrayList __label__数组 __label__Java基础语法 ArrayList   类 是 一个 可以 动态 修改 的 数组 ， 与 普通 数组 的 区别 就是 它 是 没有 固定 大小 的 限制 ， 我们 可以 添加 或 删除 元素
__label__ArrayList __label__Java多态 __label__Java接口 __label__Java继承 ArrayList   继承 了   AbstractList   ， 并 实现 了   List   接口
__label__ArrayList __label__Java包(package) ArrayList   类 位于   java . util   包中 ， 使用 前 需要 引入 它 ， 语法 格式 如下 ：
__label__ArrayList E :   泛型 数据类型 ， 用于 设置   objectName   的 数据类型 ， 只能 为 引用 数据类型
__label__ArrayList objectName :   对象 名
__label__ArrayList __label__数组 __label__Java基础语法 ArrayList   是 一个 数组 队列 ， 提供 了 相关 的 添加 、 删除 、 修改 、 遍历 等 功能
__label__HashMap HashMap
__label__HashMap HashMap   是 一个 散 列表 ， 它 存储 的 内容 是 键值 对 ( key - value ) 映射
__label__Java多态 __label__HashMap __label__Java接口 HashMap   实现 了   Map   接口 ， 根据 键 的   HashCode   值 存储 数据 ， 具有 很快 的 访问速度 ， 最 多 允许 一条 记录 的 键 为   null ， 不 支持 线程 同步
__label__HashMap HashMap   是 无序 的 ， 即 不会 记录 插入 的 顺序
__label__Java继承 __label__Java多态 __label__HashMap __label__Java接口 HashMap   继承 于 AbstractMap ， 实现 了   Map 、 Cloneable 、 java . io . Serializable   接口
__label__HashMap HashMap   的   key   与   value   类型 可以 相同 也 可以 不同 ， 可以 是 字符串 （ String ） 类型 的   key   和   value ， 也 可以 是 整型 （ Integer ） 的   key   和 字符串 （ String ） 类型 的   value
__label__Java包(package) __label__HashMap HashMap   类 位于   java . util   包中 ， 使用 前 需要 引入 它 ， 语法 格式 如下 ：
__label__HashMap 以下 实例 我们 创建 一个   HashMap   对象   Sites ，   整型 （ Integer ） 的   key   和 字符串 （ String ） 类型 的   value ：
__label__HashSet HashSet
__label__HashMap __label__HashSet HashSet   基于   HashMap   来 实现 的 ， 是 一个 不 允许 有 重复 元素 的 集合
__label__HashSet HashSet   允许 有   null   值
__label__HashSet HashSet   是 无序 的 ， 即 不会 记录 插入 的 顺序
__label__HashSet HashSet   不是 线程 安全 的 ，   如果 多个 线程 尝试 同时 修改   HashSet ， 则 最终 结果 是 不 确定 的
__label__HashSet 您 必须 在 多线程 访问 时 显式 同步 对   HashSet   的 并发 访问
__label__Java多态 __label__Java接口 __label__HashSet HashSet   实现 了   Set   接口
__label__Java包(package) __label__HashSet HashSet   类 位于   java . util   包中 ， 使用 前 需要 引入 它 ， 语法 格式 如下 ：
__label__HashSet 以下 实例 我们 创建 一个   HashSet   对象   sites ， 用于 保存 字符串 元素 ：
__label__LinkedList LinkedList
__label__LinkedList 链表 （ Linked   list ） 是 一种 常见 的 基础 数据结构 ， 是 一种 线性表 ， 但是 并 不会 按 线性 的 顺序存储 数据 ， 而是 在 每 一个 节点 里 存到 下 一个 节点 的 地址
__label__LinkedList 链表 可 分为 单向 链表 和 双向 链表
__label__Java包(package) __label__LinkedList 一个 单向 链表 包含 两个 值 :   当前 节点 的 值 和 一个 指向 下 一个 节点 的 链接
__label__LinkedList 一个 双向 链表 有 三个 整数 值 :   数值 、 向 后 的 节点 链接 、 向前 的 节点 链接
__label__ArrayList __label__LinkedList Java   LinkedList （ 链表 ）   类似 于   ArrayList ， 是 一种 常用 的 数据 容器
__label__ArrayList __label__LinkedList 与   ArrayList   相比 ， LinkedList   的 增加 和 删除 的 操作 效率 更高 ， 而 查找 和 修改 的 操作 效率 较 低
__label__ArrayList __label__LinkedList 以下 情况 使用   ArrayList   :
__label__LinkedList 频繁 访问 列表 中 的 某 一个 元素
__label__LinkedList 只 需要 在 列表 末尾 进行 添加 和 删除 元素 操作
__label__LinkedList 以下 情况 使用   LinkedList   :
__label__LinkedList 你 需要 通过 循环 迭代 来 访问 列表 中 的 某些 元素
__label__LinkedList 需要 频繁 的 在 列表 开头 、 中间 、 末尾 等 位置 进行 添加 和 删除 元素 操作
__label__Java继承 __label__LinkedList LinkedList   继承 了   AbstractSequentialList   类
__label__Java多态 __label__Java接口 __label__LinkedList LinkedList   实现 了   Queue   接口 ， 可 作为 队列 使用
__label__Java多态 __label__Java接口 __label__LinkedList LinkedList   实现 了   List   接口 ， 可 进行 列表 的 相关 操作
__label__Java多态 __label__Java接口 __label__LinkedList LinkedList   实现 了   Deque   接口 ， 可 作为 队列 使用
__label__Java多态 __label__Java接口 __label__LinkedList LinkedList   实现 了   Cloneable   接口 ， 可 实现 克隆
__label__Java多态 __label__Java接口 __label__LinkedList LinkedList   实现 了   java . io . Serializable   接口 ， 即可 支持 序列化 ， 能 通过 序列化 去 传输
__label__Java包(package) __label__LinkedList LinkedList   类 位于   java . util   包中 ， 使用 前 需要 引入 它 ， 语法 格式 如下 ：
__label__Java集合框架（Collection） Java集合框架（Collection）
__label__Java集合框架（Collection） 集合框架 被 设计 成要 满足 以下 几个 目标
__label__Java集合框架（Collection） 该 框架 必须 是 高性能 的
__label__Java集合框架（Collection） __label__数组 __label__Java基础语法 基本 集合 （ 动态 数组 ， 链表 ， 树 ， 哈希 表 ） 的 实现 也 必须 是 高效 的
__label__Java集合框架（Collection） 该 框架 允许 不同 类型 的 集合 ， 以 类似 的 方式 工作 ， 具有 高度 的 互操作性
__label__Java集合框架（Collection） 对 一个 集合 的 扩展 和 适应 必须 是 简单 的
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 为此 ， 整个 集合框架 就 围绕 一组 标准接口 而 设计
__label__HashSet __label__Java多态 __label__Java接口 __label__LinkedList __label__Java集合框架（Collection） 你 可以 直接 使用 这些 接口 的 标准 实现 ， 诸如 ：   LinkedList ,   HashSet ,   和   TreeSet   等 , 除此之外 你 也 可以 通过 这些 接口 实现 自己 的 集合
__label__Java集合框架（Collection） __label__Java包(package) 从 上面 的 集合框架 图 可以 看到 ， Java   集合框架 主要 包括 两种 类型 的 容器 ， 一种 是 集合 （ Collection ） ， 存储 一个 元素 集合 ， 另 一种 是 图 （ Map ） ， 存储 键 / 值 对 映射
__label__抽象类 __label__HashSet __label__HashMap __label__Java多态 __label__Java接口 __label__ArrayList __label__LinkedList __label__Java集合框架（Collection） Collection   接口 又 有   3   种子 类型 ， List 、 Set   和   Queue ， 再 下面 是 一些 抽象类 ， 最后 是 具体 实现 类 ， 常用 的 有   ArrayList 、 LinkedList 、 HashSet 、 Linked HashSet 、 HashMap 、 Linked HashMap   等等
__label__Java集合框架（Collection） 集合框架 是 一个 用来 代表 和 操纵 集合 的 统一 架构
__label__Java集合框架（Collection） __label__Java包(package) 所有 的 集合框架 都 包含 如下 内容 ：
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 接口 ： 是 代表 集合 的 抽象数据类型
__label__Java集合框架（Collection） 例如   Collection 、 List 、 Set 、 Map   等
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 之所以 定义 多个 接口 ， 是 为了 以 不同 的 方式 操作 集合 对象
__label__Java集合框架（Collection） 实现 （ 类 ） ： 是 集合接口 的 具体 实现
__label__HashSet __label__HashMap __label__ArrayList __label__LinkedList __label__Java集合框架（Collection） 从 本质 上 讲 ， 它们 是 可 重复使用 的 数据结构 ， 例如 ： ArrayList 、 LinkedList 、 HashSet 、 HashMap
__label__Java集合框架（Collection） __label__Java方法 算法 ： 是 实现 集合接口 的 对象 里 的 方法 执行 的 一些 有用 的 计算 ， 例如 ： 搜索 和 排序
__label__Java集合框架（Collection） __label__Java方法 __label__Java多态 __label__Java接口 这些 算法 被 称为 多态 ， 那 是因为 相同 的 方法 可以 在 相似 的 接口 上 有着 不同 的 实现
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 除了 集合 ， 该 框架 也 定义 了 几个   Map   接口 和 类
__label__Java集合框架（Collection） Map   里 存储 的 是 键 / 值 对
__label__Java集合框架（Collection） 尽管   Map   不是 集合 ， 但是 它们 完全 整合 在 集合 中
__label__Java集合框架（Collection） __label__Java多态 __label__Java包(package) __label__Java接口 Java   集合框架 提供 了 一套 性能 优良 ， 使用方便 的 接口 和 类 ， java 集合框架 位于 java . util 包中 ，   所以 当 使用 集合框架 的 时候 需要 进行 导包
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 集合框架 定义 了 一些 接口
__label__Java继承 __label__Java集合框架（Collection） 序号   1   接口 描述   Collection   接口 Collection   是 最 基本 的 集合接口 ， 一个   Collection   代表 一组   Object ， 即   Collection   的 元素 ,   Java 不 提供 直接 继承 自 Collection 的 类 ， 只 提供 继承 于 的 子 接口 ( 如 List 和 set ) 。 Collection   接口 存储 一组 不 唯一 ， 无序 的 对象 。  
__label__Java基础语法 __label__Java多态 __label__Java接口 __label__数组 __label__Java集合框架（Collection） 序号   2   接口 描述   List   接口 List 接口 是 一个 有序 的   Collection ， 使用 此 接口 能够 精确 的 控制 每个 元素 插入 的 位置 ， 能够 通过 索引 ( 元素 在 List 中 位置 ， 类似 于 数组 的 下标 ) 来 访问 List 中 的 元素 ， 第一个 元素 的 索引 为   0 ， 而且 允许 有 相同 的 元素 。 List   接口 存储 一组 不 唯一 ， 有序 （ 插入 顺序 ） 的 对象 。  
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 序号   3   接口 描述   SetSet   具有 与   Collection   完全 一样 的 接口 ， 只是 行为 上 不同 ， Set   不 保存 重复 的 元素 。 Set   接口 存储 一组 唯一 ， 无序 的 对象 。  
__label__Java继承 __label__Java集合框架（Collection） __label__Java多态 __label__Java接口 序号   4   接口 描述   SortedSet   继承 于 Set 保存 有序 的 集合 。  
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 序号   5   接口 描述   MapMap   接口 存储 一组 键值 对象 ， 提供 key （ 键 ） 到 value （ 值 ） 的 映射 。  
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 序号   6   接口 描述   Map . Entry   描述 在 一个 Map 中 的 一个 元素 （ 键 / 值 对 ） 。 是 一个   Map   的 内部 接口 。  
__label__Java继承 __label__Java集合框架（Collection） __label__Java多态 __label__Java接口 序号   7   接口 描述   SortedMap 继承 于   Map ， 使   Key   保持 在 升序 排列 。  
__label__Java集合框架（Collection） __label__Java多态 __label__Java方法 __label__Java接口 序号   8   接口 描述   Enumeration 这是 一个 传统 的 接口 和 定义 的 方法 ， 通过 它 可以 枚举 （ 一次 获得 一个 ） 对象 集合 中 的 元素 。 这个 传统 接口 已 被 迭代 器 取代 。  
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 1 .   Set   接口 实例 存储 的 是 无序 的 ， 不 重复 的 数据
__label__Java集合框架（Collection） __label__Java多态 __label__Java接口 List   接口 实例 存储 的 是 有序 的 ， 可以 重复 的 元素
__label__Java集合框架（Collection） __label__HashSet 2 .   Set 检索 效率 低下 ， 删除 和 插入 效率高 ， 插入 和 删除 不会 引起 元素 位置 改变   < 实现 类有 HashSet , TreeSet >
__label__Java集合框架（Collection） __label__数组 __label__Java基础语法 3 .   List 和 数组 类似 ， 可以 动态 增长 ， 根据 实际 存储 的 数据 的 长度 自动 增长 List 的 长度
__label__ArrayList __label__Java集合框架（Collection） __label__LinkedList 查找 元素 效率高 ， 插入 删除 效率 低 ， 因为 会 引起 其他 元素 位置 改变   < 实现 类有 ArrayList , LinkedList , Vector >
__label__Java集合框架（Collection） __label__Java包(package) Java 集合框架 为 程序员 提供 了 预先 包装 的 数据结构 和 算法 来 操纵 他们
__label__Java集合框架（Collection） 集合 是 一个 对象 ， 可 容纳 其他 对象 的 引用
__label__Java集合框架（Collection） 集合接口 声明 对 每 一种 类型 的 集合 可以 执行 的 操作
__label__Java集合框架（Collection） __label__Java多态 __label__Java包(package) __label__Java接口 集合框架 的 类 和 接口 均 在 java . util 包中
__label__数组 数组
__label__数组 __label__Java基础语法 Java   语言 中 提供 的 数组 是 用来 存储 固定 大小 的 同 类型 元素
__label__数组 __label__Java基础语法 你 可以 声明 一个 数组 变量 ， 如   numbers [ 100 ]   来 代替 直接 声明   100   个 独立 变量   number0 ， number1 ， .... ， number99
__label__数组 __label__Java基础语法 数组 可以 作为 函数 的 参数 或 返回值 使用
__label__数组 首先 必须 声明数组变量 ， 才能 在 程序 中 使用 数组
__label__数组 下面 是 声明数组变量 的 语法 ：
__label__数组 注意 :   建议 使用   dataType [ ]   arrayRefVar   的 声明 风格 声明数组变量
__label__数组 dataType   arrayRefVar [ ]   风格 是 来自   C / C++   语言   ， 在 Java 中 采用 是 为了 让   C / C++   程序员 能够 快速 理解 java 语言
__label__数组 Java 语言 使用 new 操作符 来 创建数组 ， 语法 如下 ：
__label__数组 上面 的 语法 语句 做 了 两件事 ：
__label__数组 __label__Java基础语法 一 、 使用   dataType [ arraySize ]   创建 了 一个 数组
__label__数组 __label__Java基础语法 二 、 把 新创建 的 数组 的 引用 赋值 给 变量   arrayRefVar
__label__数组 __label__Java基础语法 数组 变量 的 声明 ， 和 创建数组 可以 用 一条 语句 完成 ， 如下 所示 ：
__label__数组 另外 ， 你 还 可以 使用 如下 的 方式 创建数组
__label__数组 __label__Java基础语法 数组 的 元素 是 通过 索引 访问 的
__label__数组 __label__Java基础语法 数组 索引 从   0   开始 ， 所以 索引 值 从   0   到   arrayRefVar . length - 1
__label__数组 数组 的 元素 类型 和 数组 的 大小 都 是 确定 的 ， 所以 当 处理数组 元素 时候 ， 我们 通常 使用 基本 循环 或者   For - Each   循环
__label__多维数组 多维数组
__label__多维数组 多维数组 可以 看成 是 数组 的 数组 ， 比如 二维 数组 就是 一个 特殊 的 一维 数组 ， 其 每 一个 元素 都 是 一个 一维 数组 ， 例如 ：
__label__多维数组 1 .   直接 为 每 一维 分配 空间 ， 格式 如下 ：
__label__多维数组 type   可以 为 基本 数据类型 和 复合 数据类型 ， typeLength1   和   typeLength2   必须 为 正整数 ， typeLength1   为 行数 ， typeLength2   为 列数
__label__多维数组 解析 ：
__label__数组 __label__多维数组 __label__Java基础语法 二维 数组   a   可以 看成 一个 两行 三列 的 数组
__label__多维数组 2 .   从 最高 维 开始 ， 分别 为 每 一维 分配 空间 ， 例如 ：
__label__多维数组 解析 ：
__label__数组 __label__多维数组 __label__Java基础语法 s [ 0 ] = new   String [ 2 ]   和   s [ 1 ] = new   String [ 3 ]   是 为 最高 维 分配 引用 空间 ， 也 就是 为 最高 维 限制 其能 保存 数据 的 最长 的 长度 ， 然后 再 为 其 每个 数组 元素 单独 分配 空间   s0 = new   String ( " Good " )   等 操作
__label__数组 __label__多维数组 __label__Java基础语法 对 二维 数组 中 的 每个 元素 ， 引用 方式 为   arrayName [ index1 ] [ index2 ] ， 例如 ：
__label__Arrays类 Arrays类
__label__Java方法 __label__Arrays类 __label__数组 __label__Java基础语法 java . util . Arrays   类能 方便 地 操作 数组 ， 它 提供 的 所有 方法 都 是 静态 的
__label__Arrays类 具有 以下 功能 ：
__label__Java方法 __label__Arrays类 __label__数组 __label__Java基础语法 给 数组 赋值 ： 通过   fill   方法
__label__Java方法 __label__Arrays类 __label__数组 __label__Java基础语法 对 数组 排序 ： 通过   sort   方法 , 按 升序
__label__Java方法 __label__Arrays类 __label__数组 __label__Java基础语法 比较 数组 ： 通过   equals   方法 比较 数组 中 元素 值 是否 相等
__label__Java方法 __label__Arrays类 __label__数组 __label__Java基础语法 查找 数组 元素 ： 通过   binarySearch   方法 能 对 排序 好 的 数组 进行 二分 查找 法 操作
__label__Arrays类 具体 说明 请 查看 下表 ：
__label__Arrays类 __label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__数组 __label__Java方法 __label__Java包(package) 序号   1   方法 和 说明   public   static   int   binarySearch ( Object [ ]   a ,   Object   key ) 	 	 	 	 用 二分 查找 算法 在 给定 数组 中 搜索 给定 值 的 对象 ( Byte , Int , double 等 ) 。 数组 在 调用 前 必须 排序 好 的 。 如果 查找 值 包含 在 数组 中 ， 则 返回 搜索 键 的 索引 ； 否则 返回   ( - ( 插入 点 )   -   1 ) 。  
__label__Arrays类 __label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__数组 __label__Java方法 __label__Java包(package) 序号   2   方法 和 说明   public   static   boolean   equals ( long [ ]   a ,   long [ ]   a2 ) 	 	 	 	 如果 两个 指定 的   long   型 数组 彼此 相等 ， 则 返回   true 。 如果 两个 数组 包含 相同 数量 的 元素 ， 并且 两个 数组 中 的 所有 相应 元素 对 都 是 相等 的 ， 则 认为 这 两个 数组 是 相等 的 。 换句话说 ， 如果 两个 数组 以 相同 顺序 包含 相同 的 元素 ， 则 两个 数组 是 相等 的 。 同样 的 方法 适用 于 所有 的 其他 基本 数据类型 （ Byte ， short ， Int 等 ） 。  
__label__Arrays类 __label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__数组 __label__Java方法 序号   3   方法 和 说明   public   static   void   fill ( int [ ]   a ,   int   val ) 	 	 	 	 将 指定 的   int   值 分配 给 指定   int   型 数组 指定 范围 中 的 每个 元素 。 同样 的 方法 适用 于 所有 的 其他 基本 数据类型 （ Byte ， short ， Int 等 ） 。  
__label__Arrays类 __label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__数组 __label__Java方法 序号   4   方法 和 说明   public   static   void   sort ( Object [ ]   a ) 	 	 	 	 对 指定 对象 数组 根据 其 元素 的 自然 顺序 进行 升序 排列 。 同样 的 方法 适用 于 所有 的 其他 基本 数据类型 （ Byte ， short ， Int 等 ） 。  
__label__Java方法 Java方法
__label__Java方法 Java 方法 是 语句 的 集合 ， 它们 在 一起 执行 一个 功能
__label__Java方法 方法 是 解决 一类 问题 的 步骤 的 有序 组合
__label__Java包(package) __label__Java方法 方法 包含 于类 或 对象 中
__label__Java方法 方法 在 程序 中 被 创建 ， 在 其他 地方 被 引用
__label__Java方法 1 .   使 程序 变得 更 简短 而 清晰
__label__Java方法 2 .   有利于 程序 维护
__label__Java方法 3 .   可以 提高 程序开发 的 效率
__label__Java方法 4 .   提高 了 代码 的 重用 性
__label__Java方法 1 . 方法 的 名字 的 第一个 单词 应 以 小写字母 作为 开头 ， 后面 的 单词 则 用 大写字母 开头 写 ， 不 使用 连接符
__label__Java方法 2 . 下划线 可能 出现 在   JUnit   测试方法 名称 中 用以 分隔 名称 的 逻辑 组件
__label__Java方法 一个 典型 的 模式 是 ： test < MethodUnderTest > _ < state > ， 例如   testPop _ emptyStack
__label__Java包(package) __label__Java方法 一般 情况 下 ， 定义 一个 方法 包含 以下 语法 ：
__label__Java包(package) __label__Java方法 方法 包含 一个 方法 头 和 一个 方法 体
__label__Java方法 下面 是 一个 方法 的 所有 部分 ：
__label__Java方法 __label__Java基础语法 修饰符 ： 修饰符 ， 这是 可选 的 ， 告诉 编译器 如何 调用 该 方法
__label__Java方法 定义 了 该 方法 的 访问 类型
__label__Java方法 返回值 类型   ： 方法 可能 会 返回值
__label__Java方法 returnValueType   是 方法 返回值 的 数据类型
__label__Java方法 有些 方法 执行 所 需 的 操作 ， 但 没有 返回值
__label__Java方法 __label__Java关键字 在 这种 情况 下 ， returnValueType   是 关键字 void
__label__Java方法 方法 名 ： 是 方法 的 实际 名称
__label__Java方法 方法 名 和 参数表 共同 构成 方法 签名
__label__Java方法 参数 类型 ： 参数 像是 一个 占位 符
__label__Java方法 当 方法 被 调用 时 ， 传递 值 给 参数
__label__Java方法 __label__Java基础语法 这个 值 被 称为 实参 或 变量
__label__Java方法 参数 列表 是 指 方法 的 参数 类型 、 顺序 和 参数 的 个数
__label__Java包(package) __label__Java方法 参数 是 可选 的 ， 方法 可以 不 包含 任何 参数
__label__Java包(package) __label__Java方法 方法 体 ： 方法 体 包含 具体 的 语句 ， 定义 该 方法 的 功能
__label__Java方法 如 ：
__label__Java方法 参数 可以 有 多个 ：
__label__Java方法 注意 ：   在 一些 其它 语言 中 方法 指 过程 和 函数
__label__Java方法 一个 返回 非 void 类型 返回值 的 方法 称为 函数 ； 一个 返回 void 类型 返回值 的 方法 叫做 过程
__label__Java方法 Java   支持 两种 调用 方法 的 方式 ， 根据 方法 是否 返回值 来 选择
__label__Java方法 当 程序 调用 一个 方法 时 ， 程序 的 控制权 交给 了 被 调用 的 方法
__label__Java方法 当 被 调用 方法 的 返回 语句 执行 或者 到达 方法 体闭 括号 时候 交还 控制权 给 程序
__label__Java方法 当 方法 返回 一个 值 的 时候 ， 方法调用 通常 被 当做 一个 值
__label__Java方法 如果 方法 返回值 是 void ， 方法调用 一定 是 一条 语句
__label__Java方法 例如 ， 方法 println 返回 void
__label__Java方法 下面 的 调用 是 个 语句 ：
__label__Java方法 __label__Java基础语法 变量 的 范围 是 程序 中该 变量 可以 被 引用 的 部分
__label__Java方法 __label__Java局部变量 方法 内 定义 的 变量 被 称为 局部变量
__label__Java包(package) __label__Java方法 __label__Java局部变量 局部变量 的 作用 范围 从 声明 开始 ， 直到 包含 它 的 块 结束
__label__Java方法 __label__Java局部变量 局部变量 必须 声明 才 可以 使用
__label__Java方法 方法 的 参数 范围 涵盖 整个 方法
__label__Java方法 __label__Java局部变量 参数 实际上 是 一个 局部变量
__label__for循环 __label__Java方法 __label__Java基础语法 for 循环 的 初始化 部分 声明 的 变量 ， 其 作用 范围 在 整个 循环
__label__Java方法 __label__Java基础语法 但 循环 体内 声明 的 变量 其 适用范围 是从 它 声明 到 循环体 结束
__label__Java包(package) __label__Java方法 __label__Java基础语法 它 包含 如下 所示 的 变量 声明 ：
__label__Java方法 __label__Java局部变量 你 可以 在 一个 方法 里 ， 不同 的 非 嵌套 块 中 多次 声明 一个 具有 相同 的 名称 局部变量 ， 但 你 不能 在 嵌套 块 内 两次 声明 局部变量
__label__main方法 main方法
__label__main方法 __label__Java方法 main   方法 是 被   JVM   调用 的 ， 除此之外 ， main   方法 和 其它 方法 没什么 区别
__label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__Java方法 __label__main方法 main   方法 的 头部 是 不变 的 ， 带 修饰符   public   和   static , 返回   void   类型 值 ， 方法 名字 是   main , 此外 带个 一个   String [ ]   类型 参数
__label__main方法 __label__数组 __label__Java基础语法 String [ ]   表明 参数 是 字符串 数组
__label__main方法 有时候 你 希望 运行 一个 程序 时候 再 传递 给 它 消息
__label__main方法 这要 靠 传递 命令行 参数 给 main ( ) 函数 实现
__label__main方法 命令行 参数 是 在 执行程序 时候 紧跟 在 程序 名字 后面 的 信息
__label__构造方法 构造方法
__label__构造方法 __label__对象和类 当 一个 对象 被 创建 时候 ， 构造方法 用来 初始化 该 对象
__label__构造方法 __label__对象和类 构造方法 和 它 所在 类 的 名字 相同 ， 但 构造方法 没有 返回值
__label__构造方法 __label__实例变量 __label__对象和类 通常 会 使用 构造方法 给 一个 类 的 实例变量 赋 初值 ， 或者 执行 其它 必要 的 步骤 来 创建 一个 完整 的 对象
__label__构造方法 __label__对象和类 __label__Java基础语法 __label__访问控制修饰符 不管 你 是否 自定义 构造方法 ， 所有 的 类 都 有 构造方法 ， 因为   Java   自动 提供 了 一个 默认 构造方法 ， 默认 构造方法 的 访问修饰符 和 类 的 访问修饰符 相同 ( 类为   public ， 构造函数 也 为   public ； 类 改为   protected ， 构造函数 也 改为   protected )
__label__构造方法 __label__对象和类 一旦 你 定义 了 自己 的 构造方法 ， 默认 构造方法 就 会 失效
__label__构造方法 __label__对象和类 下面 是 一个 使用 构造方法 的 例子 ：
__label__构造方法 __label__对象和类 大多 时候 需要 一个 有 参数 的 构造方法
__label__构造方法 __label__对象和类 下面 是 一个 使用 构造方法 的 例子 ：
__label__构造方法 __label__对象和类 你 可以 像 下面 这样 调用 构造方法 来 初始化 一个 对象 ：
__label__构造方法 运行 结果 如下 ：
__label__算术运算符 算术运算符
__label__算术运算符 算术运算符 用 在 数学 表达式 中 ， 它们 的 作用 和 在 数学 中 的 作用 一样
__label__算术运算符 下 表列出 了 所有 的 算术运算符
__label__Java基础语法 __label__算术运算符 表格 中 的 实例 假设 整数 变量 A 的 值 为 10 ， 变量 B 的 值 为 20 ：
__label__算术运算符 操作符   +   描述   加法   -   相加 运算符 两侧 的 值   例子   A   +   B   等于   30  
__label__算术运算符 操作符   -   描述   减法   -   左 操作数 减去 右 操作数   例子   A   –   B   等于   - 10  
__label__算术运算符 操作符   *   描述   乘法   -   相乘 操作符 两侧 的 值   例子   A   *   B 等于 200  
__label__算术运算符 操作符   /   描述   除法   -   左 操作数 除以 右 操作数   例子   B   /   A 等于 2  
__label__算术运算符 操作符   ％   描述   取余   -   左 操作数 除以 右 操作数 的 余数   例子   B% A 等于 0  
__label__算术运算符 操作符   ++   描述   自增 :   操作数 的 值 增加 1   例子   B ++   或   ++ B   等于   21 （ 区别 详见 下文 ）  
__label__算术运算符 操作符   --   描述   自减 :   操作数 的 值 减少 1   例子   B --   或   -- B   等于   19 （ 区别 详见 下文 ）  
__label__算术运算符 1 、 自增 （ ++ ） 自减 （ -- ） 运算符 是 一种 特殊 的 算术运算符 ， 在 算术运算符 中 需要 两个 操作数 来 进行 运算 ， 而 自增自减运算符 是 一个 操作数
__label__算术运算符 2 、 前缀 自增 自 减法 ( ++ a , -- a ) :   先 进行 自增 或者 自减 运算 ， 再 进行 表达式 运算
__label__算术运算符 3 、 后缀 自增 自 减法 ( a ++ , a -- ) :   先 进行 表达式 运算 ， 再 进行 自增 或者 自减 运算
__label__关系运算符 关系运算符
__label__关系运算符 下表为 Java 支持 的 关系运算符
__label__Java基础语法 __label__关系运算符 表格 中 的 实例 整数 变量 A 的 值 为 10 ， 变量 B 的 值 为 20 ：
__label__关系运算符 运算符   = =   描述   检查 如果 两个 操作数 的 值 是否 相等 ， 如果 相等 则 条件 为 真 。   例子   （ A   = =   B ） 为 假 。  
__label__关系运算符 运算符   ! =   描述   检查 如果 两个 操作数 的 值 是否 相等 ， 如果 值 不 相等 则 条件 为 真 。   例子   ( A   ! =   B )   为 真 。  
__label__关系运算符 运算符   >   描述   检查 左 操作数 的 值 是否 大于 右 操作数 的 值 ， 如果 是 那么 条件 为 真 。   例子   （ A >   B ） 为 假 。  
__label__关系运算符 运算符   <   描述   检查 左 操作数 的 值 是否 小于 右 操作数 的 值 ， 如果 是 那么 条件 为 真 。   例子   （ A   < B ） 为 真 。  
__label__关系运算符 运算符   > =   描述   检查 左 操作数 的 值 是否 大于 或 等于 右 操作数 的 值 ， 如果 是 那么 条件 为 真 。   例子   （ A >   =   B ） 为 假 。  
__label__关系运算符 运算符   < =   描述   检查 左 操作数 的 值 是否 小于 或 等于 右 操作数 的 值 ， 如果 是 那么 条件 为 真 。   例子   （ A   < =   B ） 为 真 。  
__label__位运算符 位运算符
__label__位运算符 Java 定义 了 位运算符 ， 应用 于 整数 类型 ( int ) ， 长 整型 ( long ) ， 短 整型 ( short ) ， 字符 型 ( char ) ， 和 字节 型 ( byte ) 等 类型
__label__位运算符 位运算符 作用 在 所有 的 位 上 ， 并且 按位 运算
__label__位运算符 假设 a   =   60 ， b   =   13 ; 它们 的 二进制 格式 表示 将 如下 ：
__label__位运算符 __label__Java基础语法 下 表列出 了 位运算符 的 基本 运算 ， 假设 整数 变量   A   的 值 为   60   和 变量   B   的 值 为   13 ：
__label__位运算符 操作符   ＆   描述   如果 相对 应位 都 是 1 ， 则 结果 为 1 ， 否则 为 0   例子   （ A ＆ B ） ， 得到 12 ， 即 0000   1100  
__label__位运算符 操作符   |   描述   如果 相对 应位 都 是   0 ， 则 结果 为   0 ， 否则 为   1   例子   （ A   |   B ） 得到 61 ， 即   0011   1101  
__label__位运算符 操作符   ^   描述   如果 相对 应位 值 相同 ， 则 结果 为 0 ， 否则 为 1   例子   （ A   ^   B ） 得到 49 ， 即   0011   0001  
__label__位运算符 操作符   〜   描述   按位 取反 运算符 翻转 操作数 的 每 一位 ， 即 0 变成 1 ， 1 变成 0 。   例子   （ 〜 A ） 得到 - 61 ， 即 1100   0011  
__label__位运算符 操作符   < <   描述   按位 左移 运算符 。 左 操作数 按位 左移 右 操作数 指定 的 位数 。   例子   A   < <   2 得到 240 ， 即   1111   0000  
__label__位运算符 操作符   > >   描述   按位 右移 运算符 。 左 操作数 按位 右移 右 操作数 指定 的 位数 。   例子   A   > >   2 得到 15 即   1111  
__label__位运算符 操作符   > > >   描述   按位 右移 补零 操作符 。 左 操作数 的 值 按 右 操作数 指定 的 位数 右移 ， 移动 得到 的 空位 以 零 填充 。   例子   A > > > 2 得到 15 即 0000   1111  
__label__逻辑运算符 逻辑运算符
__label__逻辑运算符 __label__Java基础语法 下 表列出 了 逻辑运算符 的 基本 运算 ， 假设 布尔 变量 A 为 真 ， 变量 B 为 假
__label__逻辑运算符 操作符   &&   描述   称为 逻辑 与 运算符 。 当且 仅 当 两个 操作数 都 为 真 ， 条件 才 为 真 。   例子   （ A   &&   B ） 为 假 。  
__label__逻辑运算符 操作符   |   |   描述   称为 逻辑 或 操作符 。 如果 任何 两个 操作数 任何 一个 为 真 ， 条件 为 真 。   例子   （ A   |   |   B ） 为 真 。  
__label__逻辑运算符 操作符   ！   描述   称为 逻辑 非 运算符 。 用来 反转 操作数 的 逻辑 状态 。 如果 条件 为 true ， 则 逻辑 非 运算符 将 得到 false 。   例子   ！ （ A   &&   B ） 为 真 。  
__label__逻辑运算符 当 使用 与 逻辑运算符 时 ， 在 两个 操作数 都 为 true 时 ， 结果 才 为 true ， 但是 当 得到 第一个 操作 为 false 时 ， 其 结果 就 必定 是 false ， 这时候 就 不会 再 判断 第二个 操作 了
__label__赋值运算符 赋值运算符
__label__赋值运算符 下面 是 Java 语言 支持 的 赋值运算符 ：
__label__赋值运算符 操作符   =   描述   简单 的 赋值运算符 ， 将 右 操作数 的 值 赋 给 左侧 操作数   例子   C   =   A   +   B 将 把 A   +   B 得到 的 值 赋 给 C  
__label__赋值运算符 操作符   +   =   描述   加 和 赋值 操作符 ， 它 把 左 操作数 和 右 操作数 相加 赋值 给 左 操作数   例子   C   +   =   A 等价 于 C   =   C   +   A  
__label__赋值运算符 操作符   -   =   描述   减 和 赋值 操作符 ， 它 把 左 操作数 和 右 操作数 相减 赋值 给 左 操作数   例子   C   -   =   A 等价 于 C   =   C   -   A  
__label__赋值运算符 操作符   *   =   描述   乘 和 赋值 操作符 ， 它 把 左 操作数 和 右 操作数 相乘 赋值 给 左 操作数   例子   C   *   =   A 等价 于 C   =   C   *   A  
__label__赋值运算符 操作符   /   =   描述   除 和 赋值 操作符 ， 它 把 左 操作数 和 右 操作数 相除 赋值 给 左 操作数   例子   C   /   =   A ， C   与   A   同 类型 时 等价 于   C   =   C   /   A  
__label__赋值运算符 操作符   （ ％ ） =   描述   取模 和 赋值 操作符 ， 它 把 左 操作数 和 右 操作数 取模 后 赋值 给 左 操作数   例子   C ％ =   A 等价 于 C   =   C ％ A  
__label__赋值运算符 操作符   < <   =   描述   左 移位 赋值运算符   例子   C   < <   =   2 等价 于 C   =   C   < <   2  
__label__赋值运算符 操作符   > >   =   描述   右 移位 赋值运算符   例子   C   > >   =   2 等价 于 C   =   C   > >   2  
__label__赋值运算符 操作符   ＆ =   描述   按位 与 赋值运算符   例子   C ＆ =   2 等价 于 C   =   C ＆ 2  
__label__赋值运算符 操作符   ^   =   描述   按位 异或 赋值 操作符   例子   C   ^   =   2 等价 于 C   =   C   ^   2  
__label__赋值运算符 操作符   |   =   描述   按位 或 赋值 操作符   例子   C   |   =   2 等价 于 C   =   C   |   2  
__label__条件运算符（?:） 条件运算符（?:）
__label__条件运算符（?:） 条件运算符 也 被 称为 三元 运算符
__label__条件运算符（?:） 该 运算符 有 3 个 操作数 ， 并且 需要 判断 布尔 表达式 的 值
__label__条件运算符（?:） __label__Java基础语法 该 运算符 的 主要 是 决定 哪个 值 应该 赋值 给 变量
__label__Java运算符优先级 Java运算符优先级
__label__Java运算符优先级 当 多个 运算符 出现 在 一个 表达式 中 ， 谁 先 谁 后 呢 ？ 这 就 涉及 到 运算符 的 优先级 别的 问题
__label__Java运算符优先级 在 一个多 运算符 的 表达式 中 ， 运算符优先级 不同 会 导致 最后 得出 的 结果 差别 甚大
__label__Java运算符优先级 例如 ， （ 1 + 3 ） ＋ （ 3 + 2 ） * 2 ， 这个 表达式 如果 按 加号 最 优先 计算 ， 答案 就是   18 ， 如果 按照 乘号 最 优先 ， 答案 则 是   14
__label__Java运算符优先级 再 如 ， x   =   7   +   3   *   2 ; 这里 x 得到 13 ， 而 不是 20 ， 因为 乘法 运算符 比 加法 运算符 有 较 高 的 优先级 ， 所以 先 计算 3   *   2 得到 6 ， 然后 再加 7
__label__Java运算符优先级 下表中 具有 最高 优先级 的 运算符 在 的 表 的 最 上面 ， 最 低优先级 的 在 表 的 底部
__label__Java运算符优先级 类别   后缀   操作符   ( )   [ ]   .   ( 点 操作符 )   关联性   左到 右  
__label__Java运算符优先级 类别   一元   操作符   expr ++     expr --   关联性   从左到右  
__label__Java运算符优先级 类别   一元   操作符   ++ expr   -- expr   +   -   ～   ！   关联性   从右到左  
__label__Java运算符优先级 类别   乘性   操作符   *   / ％   关联性   左到 右  
__label__Java运算符优先级 类别   加性   操作符   +   -   关联性   左到 右  
__label__Java运算符优先级 类别   移位   操作符   > >   > > >     < <   关联性   左到 右  
__label__Java运算符优先级 类别   关系   操作符   >     > =     <     < =   关联性   左到 右  
__label__Java运算符优先级 类别   相等   操作符   = =     ! =   关联性   左到 右  
__label__Java运算符优先级 类别   按位 与   操作符   ＆   关联性   左到 右  
__label__Java运算符优先级 类别   按位 异或   操作符   ^   关联性   左到 右  
__label__Java运算符优先级 类别   按位 或   操作符   |   关联性   左到 右  
__label__Java运算符优先级 类别   逻辑 与   操作符   &&   关联性   左到 右  
__label__Java运算符优先级 类别   逻辑 或   操作符   |   |   关联性   左到 右  
__label__Java运算符优先级 类别   条件   操作符   ？ ：   关联性   从右到左  
__label__Java运算符优先级 类别   赋值   操作符   =   +   =   -   =   *   =   /   = ％ =   > >   =   < <   = ＆ =   ^   =   |   =   关联性   从右到左  
__label__Java运算符优先级 类别   逗号   操作符   ，   关联性   左到 右  
__label__switch-case语句 switch-case语句
__label__switch-case语句 __label__Java基础语法 switch   case   语句 判断 一个 变量 与 一系列 值中 某个 值 是否 相等 ， 每个 值 称为 一个 分支
__label__switch-case语句 switch   case   语句 语法 格式 如下 ：
__label__switch-case语句 switch   case   语句 有 如下 规则 ：
__label__switch-case语句 __label__Java基础语法 switch   语句 中 的 变量 类型 可以 是 ：   byte 、 short 、 int   或者   char
__label__Java常量 __label__switch-case语句 从   Java   SE   7   开始 ， switch   支持 字符串   String   类型 了 ， 同时   case   标签 必须 为 字符串 常量 或 字面 量
__label__switch-case语句 switch   语句 可以 拥有 多个   case   语句
__label__switch-case语句 每个   case   后面 跟 一个 要 比较 的 值 和 冒号
__label__Java常量 __label__switch-case语句 __label__Java基础语法 case   语句 中 的 值 的 数据类型 必须 与 变量 的 数据类型 相同 ， 而且 只能 是 常量 或者 字面 常量
__label__switch-case语句 __label__Java基础语法 当 变量 的 值 与   case   语句 的 值 相等 时 ， 那么   case   语句 之后 的 语句 开始 执行 ， 直到   break   语句 出现 才 会 跳出   switch   语句
__label__switch-case语句 当 遇到   break   语句 时 ， switch   语句 终止
__label__switch-case语句 程序 跳转 到   switch   语句 后面 的 语句 执行
__label__Java包(package) __label__switch-case语句 case   语句 不 必须 要 包含   break   语句
__label__switch-case语句 如果 没有   break   语句 出现 ， 程序 会 继续执行 下 一条   case   语句 ， 直到 出现   break   语句
__label__Java包(package) __label__switch-case语句 switch   语句 可以 包含 一个   default   分支 ， 该 分支 一般 是   switch   语句 的 最后 一个 分支 （ 可以 在 任何 位置 ， 但 建议 在 最后 一个 ）
__label__switch-case语句 __label__Java基础语法 default   在 没有   case   语句 的 值 和 变量值 相等 的 时候 执行
__label__switch-case语句 default   分支 不 需要   break   语句
__label__switch-case语句 switch   case   执行 时 ， 一定 会先 进行 匹配 ， 匹配 成功 返回 当前   case   的 值 ， 再 根据 是否 有   break ， 判断 是否 继续 输出 ， 或是 跳出 判断
__label__if-else语句 if-else语句
__label__Java包(package) __label__if-else语句 一个   if   语句 包含 一个 布尔 表达式 和 一条 或 多条 语句
__label__if-else语句 if   语句 的 语法 如下 ：
__label__if-else语句 如果 布尔 表达式 的 值 为   true ， 则 执行   if   语句 中 的 代码 块 ， 否则 执行   if   语句 块 后面 的 代码
__label__if-else语句 if   语句 后面 可以 跟   else   语句 ， 当   if   语句 的 布尔 表达式 值为   false   时 ， else   语句 块 会 被 执行
__label__if-else语句 if … else   的 用法 如下 ：
__label__if-else语句 if   语句 后面 可以 跟   else   if … else   语句 ， 这种 语句 可以 检测 到 多种 可能 的 情况
__label__if-else语句 使用   if ， else   if ， else   语句 的 时候 ， 需要 注意 下面 几点 ：
__label__if-else语句 if   语句 至多 有   1   个   else   语句 ， else   语句 在 所有 的   else   if   语句 之后
__label__if-else语句 if   语句 可以 有 若干个   else   if   语句 ， 它们 必须 在   else   语句 之前
__label__if-else语句 一旦 其中 一个   else   if   语句 检测 为   true ， 其他 的   else   if   以及   else   语句 都 将 跳 过 执行
__label__if-else语句 if...else   if...else 语法 格式 如下 :
__label__if-else语句 使用 嵌套 的   if … else   语句 是 合法 的
__label__if-else语句 也就是说 你 可以 在 另 一个   if   或者   else   if   语句 中 使用   if   或者   else   if   语句
__label__if-else语句 嵌套 的   if … else   语法 格式 如下 ：
__label__if-else语句 你 可以 像   if   语句 一样 嵌套   else   if...else
__label__Java包(package) Java包(package)
__label__Java包(package) 为了 更好 地 组织 类 ， Java   提供 了 包 机制 ， 用于 区别 类名 的 命名 空间
__label__Java多态 __label__Java包(package) __label__Java接口 1 、 把 功能 相似 或 相关 的 类 或 接口 组织 在 同一个 包中 ， 方便 类 的 查找 和 使用
__label__Java包(package) 2 、 如同 文件夹 一样 ， 包 也 采用 了 树形 目录 的 存储 方式
__label__对象和类 __label__Java包(package) 同一个 包 中的类 名字 是 不同 的 ， 不同 的 包 中的类 的 名字 是 可以 相同 的 ， 当 同时 调用 两个 不同 包中 相同 类名 的 类时 ， 应该 加上 包名 加以 区别
__label__Java包(package) 因此 ， 包 可以 避免 名字 冲突
__label__对象和类 __label__Java包(package) 3 、 包 也 限定 了 访问 权限 ， 拥有 包 访问 权限 的 类 才能 访问 某个 包 中的类
__label__Java多态 __label__Java包(package) __label__Java接口 Java   使用 包 （ package ） 这种 机制 是 为了 防止 命名 冲突 ， 访问控制 ， 提供 搜索 和 定位 类 （ class ） 、 接口 、 枚举 （ enumerations ） 和 注释 （ annotation ） 等
__label__Java包(package) 包 语句 的 语法 格式 为 ：
__label__Java包(package) 例如 , 一个 Something . java   文件 它 的 内容
__label__Java包(package) 那么 它 的 路径 应该 是   net / java / util / Something . java   这样 保存 的
__label__Java包(package) package ( 包 )   的 作用 是 把 不同 的   java   程序 分类 保存 ， 更 方便 的 被 其他   java   程序 调用
__label__Java多态 __label__Java包(package) __label__Java接口 一个包 （ package ） 可以 定义 为 一组 相互 联系 的 类型 （ 类 、 接口 、 枚举 和 注释 ） ， 为 这些 类型 提供 访问 保护 和 命名 空间 管理 的 功能
__label__Java包(package) 以下 是 一些   Java   中 的 包 ：
__label__Java包(package) java . lang - 打包 基础 的 类
__label__Java包(package) java . io - 包含 输入输出 功能 的 函数
__label__Java多态 __label__Java包(package) __label__Java接口 开发者 可以 自己 把 一组 类 和 接口 等 打包 ， 并 定义 自己 的 包
__label__Java多态 __label__Java包(package) __label__Java接口 而且 在 实际 开发 中 这样 做 是 值得 提倡 的 ， 当 你 自己 完成 类 的 实现 之后 ， 将 相关 的 类 分组 ， 可以 让 其他 的 编程 者 更 容易 地 确定 哪些 类 、 接口 、 枚举 和 注释 等 是 相关 的
__label__Java包(package) 由于 包 创建 了 新 的 命名 空间 （ namespace ） ， 所以 不会 跟 其他 包中 的 任何 名字 产生 命名 冲突
__label__Java包(package) 使用 包 这种 机制 ， 更 容易 实现 访问控制 ， 并且 让 定位 相关 类 更加 简单
__label__Java包(package) 创建包 的 时候 ， 你 需要 为 这个 包取 一个 合适 的 名字
__label__Java多态 __label__Java包(package) __label__Java接口 之后 ， 如果 其他 的 一个 源文件 包含 了 这个 包 提供 的 类 、 接口 、 枚举 或者 注释 类型 的 时候 ， 都 必须 将 这个 包 的 声明 放在 这个 源文件 的 开头
__label__Java包(package) 包 声明 应该 在 源文件 的 第一行 ， 每个 源文件 只能 有 一个包 声明 ， 这个 文件 中 的 每个 类型 都 应用 于 它
__label__对象和类 __label__Java包(package) 如果 一个 源文件 中 没有 使用 包 声明 ， 那么 其中 的 类 ， 函数 ， 注释 等 将 被 放在 一个 无名 的 包 （ unnamed   package ） 中
__label__Java包(package) 为了 能够 使用 某 一个包 的 成员 ， 我们 需要 在   Java   程序 中 明确 导入 该包
__label__Java包(package) 使用   " import "   语句 可 完成 此 功能
__label__Java包(package) 在   java   源文件 中   import   语句 应 位于   package   语句 之后 ， 所有 类 的 定义 之前 ， 可以 没有 ， 也 可以 有 多条 ， 其 语法 格式 为 ：
__label__Java包(package) 如果 在 一个包 中 ， 一个 类 想要 使用 本包 中 的 另 一个 类 ， 那么 该 包名 可以 省略
__label__Java包(package) 下面 的   payroll   包 已经 包含 了   Employee   类 ， 接下来 向   payroll   包中 添加 一个   Boss   类
__label__Java包(package) Boss   类 引用   Employee   类 的 时候 可以 不用 使用   payroll   前缀 ， Boss   类 的 实例 如下
__label__Java方法 __label__对象和类 __label__Java包(package) 如果   Boss   类 不 在   payroll   包中 又 会 怎样 ？ Boss   类 必须 使用 下面 几种 方法 之一 来 引用 其他 包 中的类
__label__Java包(package) 使用 类 全名 描述 ， 例如 ：
__label__Java包(package) __label__Java关键字 用   import   关键字 引入 ， 使用 通配符   * ：
__label__Java包(package) __label__Java关键字 使用   import   关键字 引入   Employee   类 ：
__label__Java包(package) 注意 ：
__label__Java包(package) 类 文件 中 可以 包含 任意 数量 的   import   声明
__label__Java包(package) import   声明 必须 在 包 声明 之后 ， 类 声明 之前
__label__Java包(package) 类 放在 包中会 有 两种 主要 的 结果 ：
__label__Java包(package) 包名 成为 类名 的 一部分 ， 正如 我们 前面 讨论 的 一样
__label__Java包(package) 包名 必须 与 相应 的 字节 码 所在 的 目录 结构 相吻合
__label__Java包(package) 下面 是 管理 你 自己   java   中 文件 的 一种 简单 方式 ：
__label__Java多态 __label__Java包(package) __label__Java接口 将类 、 接口 等 类型 的 源码 放在 一个 文本 中 ， 这个 文件 的 名字 就是 这个 类型 的 名字 ， 并 以 . java 作为 扩展名
__label__Java包(package) 接下来 ， 把 源文件 放在 一个 目录 中 ， 这个 目录 要 对应 类 所在 包 的 名字
__label__Java包(package) 现在 ， 正确 的 类名 和 路径 将会 是 如下 样子 ：
__label__Java包(package) 类名   - >     vehicle . Car
__label__Java包(package) 路径名   - >       vehicle \ Car . java   ( 在   windows   系统 中 )
__label__Java多态 Java多态
__label__Java多态 多态 是 同一个 行为 具有 多个 不同 表现形式 或 形态 的 能力
__label__Java接口 __label__Java多态 多态 就是 同一个 接口 ， 使用 不同 的 实例 而 执行 不同 操作 ， 如图所示 ：
__label__Java多态 多态性 是 对象 多种 表现形式 的 体现
__label__Java多态 现实 中 ， 比如 我们 按下   F1   键 这个 动作 ：
__label__Java多态 如果 当前 在   Flash   界面 下弹 出 的 就是   AS   3   的 帮助 文档 ；
__label__Java多态 如果 当前 在   Word   下弹 出 的 就是   Word   帮助 ；
__label__Java多态 在   Windows   下弹 出 的 就是   Windows   帮助 和 支持
__label__Java多态 同一个 事件 发生 在 不同 的 对象 上 会 产生 不同 的 结果
__label__Java多态 1 .   消除 类型 之间 的 耦合 关系
__label__Java多态 2 .   可 替换 性
__label__Java多态 3 .   可扩充性
__label__Java接口 __label__Java多态 4 .   接口 性
__label__Java多态 5 .   灵活性
__label__Java多态 6 .   简化 性
__label__Java继承 __label__Java多态 继承
__label__重写(Override) __label__Java多态 重写
__label__Java多态 父类 引用 指向 子类 对象 ： Parent   p   =   new   Child ( ) ;
__label__Java方法 __label__Java多态 当 使用 多态 方式 调用 方法 时 ， 首先 检查 父类 中 是否 有 该 方法 ， 如果 没有 ， 则 编译 错误 ； 如果 有 ， 再 去 调用 子类 的 同名 方法
__label__Java多态 多态 的 好处 ： 可以 使 程序 有 良好 的 扩展 ， 并 可以 对 所有 类 的 对象 进行 通用 处理
__label__Java接口 __label__Java多态 1 .   生活 中 的 接口 最具 代表性 的 就是 插座 ， 例如 一个 三接头 的 插头 都 能 接 在 三孔 插座 中 ， 因为 这个 是 每个 国家 都 有 各自 规定 的 接口 规则 ， 有 可能 到 国外 就 不行 ， 那 是因为 国外 自己 定义 的 接口类型
__label__Java接口 __label__Java方法 __label__Java多态 2 .   java 中 的 接口 类似 于 生活 中 的 接口 ， 就是 一些 方法 特征 的 集合 ， 但 没有 方法 的 实现
__label__对象和类 对象和类
__label__对象和类 对象 ： 对象 是 类 的 一个 实例 ， 有 状态 和 行为
__label__对象和类 例如 ， 一条 狗 是 一个 对象 ， 它 的 状态 有 ： 颜色 、 名字 、 品种 ； 行为 有 ： 摇尾巴 、 叫 、 吃 等
__label__对象和类 类 ： 类 是 一个 模板 ， 它 描述 一类 对象 的 行为 和 状态
__label__对象和类 现在 让 我们 深入 了解 什么 是 对象
__label__对象和类 看看 周围 真实 的 世界 ， 会 发现 身边 有 很多 对象 ， 车 ， 狗 ， 人 等等
__label__对象和类 所有 这些 对象 都 有 自己 的 状态 和 行为
__label__对象和类 拿 一条 狗来 举例 ， 它 的 状态 有 ： 名字 、 品种 、 颜色 ， 行为 有 ： 叫 、 摇尾巴 和 跑
__label__对象和类 对比 现实 对象 和 软件 对象 ， 它们 之间 十分相似
__label__对象和类 软件 对象 也 有 状态 和 行为
__label__Java方法 __label__对象和类 软件 对象 的 状态 就是 属性 ， 行为 通过 方法 体现
__label__Java方法 __label__对象和类 在 软件开发 中 ， 方法 操作 对象 内部 状态 的 改变 ， 对象 的 相互 调用 也 是 通过 方法 来 完成
__label__对象和类 类 可以 看成 是 创建   Java   对象 的 模板
__label__对象和类 通过 上 图 创建 一个 简单 的 类来 理解 下   Java   中类 的 定义 ：
__label__Java包(package) __label__对象和类 __label__Java基础语法 一个 类 可以 包含 以下 类型 变量 ：
__label__构造方法 __label__对象和类 __label__Java局部变量 局部变量 ： 在 方法 、 构造方法 或者 语句 块 中 定义 的 变量 被 称为 局部变量
__label__Java方法 __label__对象和类 __label__Java基础语法 变量 声明 和 初始化 都 是 在 方法 中 ， 方法 结束 后 ， 变量 就 会 自动 销毁
__label__Java方法 __label__对象和类 __label__Java基础语法 成员 变量 ： 成员 变量 是 定义 在 类 中 ， 方法 体 之外 的 变量
__label__对象和类 __label__Java基础语法 这种 变量 在 创建对象 的 时候 实例 化
__label__构造方法 __label__对象和类 __label__Java基础语法 成员 变量 可以 被 类 中 方法 、 构造方法 和 特定 类 的 语句 块 访问
__label__类变量（静态变量） __label__对象和类 __label__非访问修饰符 __label__Java方法 类变量 ： 类变量 也 声明 在 类 中 ， 方法 体 之外 ， 但 必须 声明 为   static   类型
__label__Java方法 __label__对象和类 一个 类 可以 拥有 多个 方法 ， 在 上面 的 例子 中 ： eat ( ) 、 run ( ) 、 sleep ( )   和   name ( )   都 是   Dog   类 的 方法
__label__构造方法 __label__对象和类 每个 类 都 有 构造方法
__label__构造方法 __label__对象和类 如果 没有 显式 地 为 类 定义 构造方法 ， Java   编译器 将会 为 该类 提供 一个 默认 构造方法
__label__构造方法 __label__对象和类 在 创建 一个 对象 的 时候 ， 至少 要 调用 一个 构造方法
__label__构造方法 __label__对象和类 构造方法 的 名称 必须 与 类 同名 ， 一个 类 可以 有 多个 构造方法
__label__构造方法 __label__对象和类 下面 是 一个 构造方法 示例 ：
__label__对象和类 对象 是 根据 类 创建 的
__label__对象和类 __label__Java关键字 在 Java 中 ， 使用 关键字   new   来 创建 一个 新 的 对象
__label__对象和类 创建对象 需要 以下 三步 ：
__label__Java包(package) __label__对象和类 声明 ： 声明 一个 对象 ， 包括 对象 名称 和 对象 类型
__label__对象和类 __label__Java关键字 实例 化 ： 使用 关键字   new   来 创建 一个 对象
__label__构造方法 __label__对象和类 初始化 ： 使用   new   创建对象 时 ， 会 调用 构造方法 初始化 对象
__label__Java方法 __label__对象和类 __label__Java基础语法 通过 已 创建 的 对象 来 访问 成员 变量 和 成员 方法 ， 如下 所示 ：
__label__Java包(package) __label__对象和类 当 在 一个 源文件 中 定义 多个 类 ， 并且 还有 import 语句 和 package 语句 时 ， 要 特别 注意 这些 规则
__label__对象和类 __label__访问控制修饰符 一个 源文件 中 只能 有 一个   public   类
__label__对象和类 __label__访问控制修饰符 一个 源文件 可以 有 多个 非   public   类
__label__对象和类 __label__访问控制修饰符 源文件 的 名称 应该 和   public   类 的 类名 保持一致
__label__Java包(package) __label__对象和类 如果 一个 类 定义 在 某个 包中 ， 那么   package   语句 应该 在 源文件 的 首行
__label__Java包(package) __label__对象和类 如果 源文件 包含   import   语句 ， 那么 应该 放在   package   语句 和 类 定义 之间
__label__Java包(package) __label__对象和类 如果 没有   package   语句 ， 那么   import   语句 应该 在 源文件 中 最 前面
__label__Java包(package) __label__对象和类 import   语句 和   package   语句 对 源文件 中 定义 的 所有 类 都 有效
__label__Java包(package) __label__对象和类 在 同一 源文件 中 ， 不能 给 不同 的 类 不同 的 包 声明
__label__Java封装 Java封装
__label__Java封装 __label__Java包(package) __label__Java方法 __label__Java接口 在 面向对象 程式设计 方法 中 ， 封装 （ 英语 ： Encapsulation ） 是 指 一种 将 抽象性 函式 接口的实现 细节 部分 包装 、 隐藏 起来 的 方法
__label__Java封装 封装 可以 被 认为 是 一个 保护 屏障 ， 防止 该类 的 代码 和 数据 被 外部类 定义 的 代码 随机 访问
__label__Java封装 __label__Java多态 __label__Java接口 要 访问 该类 的 代码 和 数据 ， 必须 通过 严格 的 接口 控制
__label__Java封装 封装 最 主要 的 功能 在于 我们 能 修改 自己 的 实现 代码 ， 而 不用 修改 那些 调用 我们 代码 的 程序 片段
__label__Java封装 适当 的 封装 可以 让 程式码 更 容易 理解 与 维护 ， 也 加强 了 程式码 的 安全性
__label__Java封装 1 .   良好 的 封装 能够 减少 耦合
__label__Java封装 2 .   类 内部 的 结构 可以 自由 修改
__label__Java封装 __label__Java基础语法 3 .   可以 对 成员 变量 进行 更 精确 的 控制
__label__Java封装 4 .   隐藏 信息 ， 实现 细节
__label__Java封装 __label__访问控制修饰符 1 .   修改 属性 的 可见 性来 限制 对 属性 的 访问 （ 一般 限制 为 private ） ， 例如 ：
__label__Java封装 这 段 代码 中 ， 将   name   和   age   属性 设置 为 私有 的 ， 只能 本 类 才能 访问 ， 其他 类 都 访问 不了 ， 如此 就 对 信息 进行 了 隐藏
__label__Java封装 __label__Java方法 2 .   对 每个 值 属性 提供 对外 的 公共 方法 访问 ， 也 就是 创建 一对 赋 取值 方法 ， 用于 对 私有 属性 的 访问 ， 例如 ：
__label__访问控制修饰符 __label__Java继承 __label__Java封装 __label__Java局部变量 __label__实例变量 __label__Java关键字 采用   this   关键字 是 为了 解决 实例变量 （ private   String   name ） 和 局部变量 （ setName ( String   name ) 中 的 name 变量 ） 之间 发生 的 同名 的 冲突
__label__抽象类 抽象类
__label__Java包(package) __label__Java多态 __label__抽象类 在 面向对象 的 概念 中 ， 所有 的 对象 都 是 通过 类来 描绘 的 ， 但是 反过来 ， 并 不是 所有 的 类 都 是 用来 描绘 对象 的 ， 如果 一个 类中 没有 包含 足够 的 信息 来 描绘 一个 具体 的 对象 ， 这样 的 类 就是 抽象类
__label__Java基础语法 __label__抽象类 __label__构造方法 __label__Java多态 __label__对象和类 抽象类 除了 不能 实例 化 对象 之外 ， 类 的 其它 功能 依然 存在 ， 成员 变量 、 成员 方法 和 构造方法 的 访问 方式 和 普通 类 一样
__label__Java继承 __label__Java多态 __label__抽象类 由于 抽象类 不能 实例 化 对象 ， 所以 抽象类 必须 被 继承 ， 才能 被 使用
__label__Java多态 __label__抽象类 也 是因为 这个 原因 ， 通常 在 设计阶段 决定 要 不要 设计 抽象类
__label__Java方法 __label__Java包(package) __label__抽象类 父类 包含 了 子类 集合 的 常见 的 方法 ， 但是 由于 父类 本身 是 抽象 的 ， 所以 不能 使用 这些 方法
__label__Java继承 __label__Java接口 __label__Java多态 __label__抽象类 在   Java   中 抽象类 表示 的 是 一种 继承 关系 ， 一个 类 只能 继承 一个 抽象类 ， 而 一个 类 却 可以 实现 多个 接口
__label__Java包(package) __label__Java多态 __label__抽象类 如果 你 想 设计 这样 一个 类 ， 该类 包含 一个 特别 的 成员 方法 ， 该 方法 的 具体 实现 由 它 的 子类 确定 ， 那么 你 可以 在 父类 中 声明 该 方法 为 抽象方法
__label__Java关键字 __label__Java包(package) __label__Java多态 __label__抽象类 Abstract   关键字 同样 可以 用来 声明 抽象方法 ， 抽象方法 只 包含 一个 方法 名 ， 而 没有 方法 体
__label__Java多态 __label__抽象类 抽象方法 没有 定义 ， 方法 名 后面 直接 跟 一个 分 号 ， 而 不是 花 括号
__label__Java多态 __label__抽象类 声明 抽象方法 会 造成 以下 两个 结果 ：
__label__Java包(package) __label__Java多态 __label__抽象类 如果 一个 类 包含 抽象方法 ， 那么 该类 必须 是 抽象类
__label__重写(Override) __label__Java多态 __label__抽象类 任何 子类 必须 重写 父类 的 抽象方法 ， 或者 声明 自身 为 抽象类
__label__Java继承 __label__重写(Override) __label__Java多态 __label__抽象类 继承 抽象方法 的 子类 必须 重写 该 方法
__label__Java多态 __label__抽象类 否则 ， 该 子类 也 必须 声明 为 抽象类
__label__Java多态 __label__抽象类 最终 ， 必须 有 子类 实现 该 抽象方法 ， 否则 ， 从 最初 的 父类 到 最终 的 子类 都 不能 用来 实例 化 对象
__label__Java继承 __label__Java方法 __label__抽象类 如果 Salary 类 继承 了 Employee 类 ， 那么 它 必须 实现 computePay ( ) 方法
__label__Java多态 __label__抽象类 1 .   抽象类 不能 被 实例 化 ( 初学者 很 容易 犯 的 错 ) ， 如果 被 实例 化 ， 就 会 报错 ， 编译 无法 通过
__label__对象和类 __label__Java多态 __label__抽象类 只有 抽象类 的 非 抽象 子类 可以 创建对象
__label__Java包(package) __label__Java多态 __label__抽象类 2 .   抽象类 中 不 一定 包含 抽象方法 ， 但是 有 抽象方法 的 类 必定 是 抽象类
__label__Java包(package) __label__Java多态 __label__抽象类 3 .   抽象类 中 的 抽象方法 只是 声明 ， 不 包含 方法 体 ， 就是 不 给出 方法 的 具体 实现 也 就是 方法 的 具体 功能
__label__抽象类 __label__非访问修饰符 __label__构造方法 __label__Java多态 __label__对象和类 4 .   构造方法 ， 类 方法 （ 用   static   修饰 的 方法 ） 不能 声明 为 抽象方法
__label__Java多态 __label__抽象类 5 .   抽象类 的 子类 必须 给出 抽象类 中 的 抽象方法 的 具体 实现 ， 除非 该 子类 也 是 抽象类
__label__Java接口 Java接口
__label__Java多态 __label__Java接口 __label__抽象类 接口 （ 英文 ： Interface ） ， 在 JAVA 编程语言 中是 一个 抽象 类型 ， 是 抽象方法 的 集合 ， 接口 通常 以 interface 来 声明
__label__Java继承 __label__Java多态 __label__Java接口 __label__抽象类 一个 类 通过 继承 接口 的 方式 ， 从而 来 继承 接口 的 抽象方法
__label__Java多态 __label__Java接口 接口 并 不是 类 ， 编写 接口 的 方式 和 类 很 相似 ， 但是 它们 属于 不同 的 概念
__label__Java方法 __label__Java接口 类 描述 对象 的 属性 和 方法
__label__Java方法 __label__Java多态 __label__Java包(package) __label__Java接口 接口 则 包含 类要 实现 的 方法
__label__Java多态 __label__Java方法 __label__Java接口 __label__抽象类 除非 实现 接口 的 类 是 抽象类 ， 否则 该类 要 定义 接口 中 的 所有 方法
__label__Java多态 __label__Java接口 接口 无法 被 实例 化 ， 但是 可以 被 实现
__label__Java多态 __label__Java方法 __label__Java接口 __label__抽象类 一个 实现 接口 的 类 ， 必须 实现 接口 内所 描述 的 所有 方法 ， 否则 就 必须 声明 为 抽象类
__label__Java多态 __label__Java接口 __label__Java基础语法 另外 ， 在   Java   中 ， 接口类型 可用 来 声明 一个 变量 ， 他们 可以 成为 一个 空 指针 ， 或是 被 绑定 在 一个 以此 接口 实现 的 对象
__label__Java多态 __label__Java方法 __label__Java接口 一个 接口 可以 有 多个 方法
__label__Java多态 __label__Java接口 接口 文件 保存 在   . java   结尾 的 文件 中 ， 文件名 使用 接口 名
__label__Java多态 __label__Java接口 接口 的 字节 码 文件 保存 在   . class   结尾 的 文件 中
__label__Java多态 __label__Java包(package) __label__Java接口 接口 相应 的 字节 码 文件 必须 在 与 包 名称 相匹配 的 目录 结构 中
__label__Java多态 __label__Java接口 接口 不能 用于 实例 化 对象
__label__构造方法 __label__Java多态 __label__对象和类 __label__Java接口 接口 没有 构造方法
__label__Java关键字 __label__Java多态 __label__Java接口 __label__抽象类 接口 中 所有 的 方法 必须 是 抽象方法 ， Java   8   之后   接口 中 可以 使用   default   关键字 修饰 的 非 抽象方法
__label__Java基础语法 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__Java接口 __label__Java包(package) 接口 不能 包含 成员 变量 ， 除了   static   和   final   变量
__label__Java继承 __label__Java多态 __label__Java接口 接口 不是 被 类 继承 了 ， 而是 要 被 类 实现
__label__Java继承 __label__Java多态 __label__Java接口 接口 支持 多 继承
__label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__Java多态 __label__Java接口 __label__Java方法 接口 中 每 一个 方法 也 是 隐式 抽象 的 , 接口 中 的 方法 会 被 隐式 的 指定 为   public   abstract （ 只能 是     public   abstract ， 其他 修饰符 都 会 报错 ）
__label__Java基础语法 __label__访问控制修饰符 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__Java接口 接口 中 可以 含有 变量 ， 但是 接口 中 的 变量 会 被 隐式 的 指定 为   public   static   final   变量 （ 并且 只能 是   public ， 用   private   修饰 会 报 编译 错误 ）
__label__Java多态 __label__Java方法 __label__Java接口 接口 中 的 方法 是 不能 在 接口 中 实现 的 ， 只能 由 实现 接口 的 类来 实现 接口 中 的 方法
__label__Java多态 __label__Java方法 __label__Java接口 __label__抽象类 1 .   抽象类 中 的 方法 可以 有 方法 体 ， 就是 能 实现 方法 的 具体 功能 ， 但是 接口 中 的 方法 不行
__label__Java基础语法 __label__访问控制修饰符 __label__抽象类 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__Java接口 2 .   抽象类 中 的 成员 变量 可以 是 各种类型 的 ， 而 接口 中 的 成员 变量 只能 是   public   static   final   类型 的
__label__抽象类 __label__非访问修饰符 __label__Java多态 __label__Java接口 __label__Java方法 3 .   接口 中 不能 含有 静态 代码 块 以及 静态方法 ( 用   static   修饰 的 方法 ) ， 而 抽象类 是 可以 有 静态 代码 块 和 静态方法
__label__Java继承 __label__Java多态 __label__Java接口 __label__抽象类 4 .   一个 类 只能 继承 一个 抽象类 ， 而 一个 类 却 可以 实现 多个 接口
__label__Java多态 __label__Java方法 __label__Java接口 注 ： JDK   1.8   以后 ， 接口 里 可以 有 静态方法 和 方法 体 了
__label__Java多态 __label__Java接口 __label__Java方法 __label__Java包(package) __label__Java关键字 注 ： JDK   1.8   以后 ， 接口 允许 包含 具体 实现 的 方法 ， 该 方法 称为 " 默认 方法 " ， 默认 方法 使用   default   关键字 修饰
__label__Java方法 __label__Java接口 __label__访问控制修饰符 注 ： JDK   1.9   以后 ， 允许 将 方法 定义 为   private ， 使得 某些 复用 的 代码 不会 把 方法 暴露 出去
__label__Java接口 接口的声明 语法 格式 如下 ：
__label__Java多态 __label__Java接口 __label__Java关键字 Interface 关键字 用来 声明 一个 接口
__label__非访问修饰符 __label__Java多态 __label__Java接口 __label__Java关键字 接口 是 隐式 抽象 的 ， 当 声明 一个 接口 的 时候 ， 不必 使用 abstract 关键字
__label__非访问修饰符 __label__Java多态 __label__Java接口 __label__Java方法 __label__Java关键字 接口 中 每 一个 方法 也 是 隐式 抽象 的 ， 声明 时 同样 不 需要 abstract 关键字
__label__Java多态 __label__Java方法 __label__Java接口 接口 中 的 方法 都 是 公有 的
__label__Java多态 __label__Java方法 __label__Java接口 当类 实现 接口 的 时候 ， 类要 实现 接口 中 所有 的 方法
__label__Java接口 否则 ， 类 必须 声明 为 抽象 的 类
__label__Java继承 __label__Java多态 __label__Java接口 类 使用 implements 关键字 实现 接口
__label__Java接口 __label__Java关键字 在 类 声明 中 ， Implements 关键字 放在 class 声明 后面
__label__Java多态 __label__Java接口 实现 一个 接口 的 语法 ， 可以 使用 这个 公式 ：
__label__Java方法 __label__重写(Override) __label__Java多态 __label__Java接口 重写 接口 中 声明 的 方法 时 ， 需要 注意 以下 规则 ：
__label__抽象类 __label__Java继承 __label__Java多态 __label__Java接口 __label__Java方法 __label__Java异常 类 在 实现 接口 的 方法 时 ， 不能 抛出 强制性 异常 ， 只能 在 接口 中 ， 或者 继承 接口 的 抽象类 中 抛出 该 强制性 异常
__label__Java方法 __label__重写(Override) __label__Java多态 __label__Java接口 类 在 重写 方法 时要 保持一致 的 方法 名 ， 并且 应该 保持 相同 或者 相 兼容 的 返回值 类型
__label__Java多态 __label__Java方法 __label__Java接口 __label__抽象类 如果 实现 接口 的 类 是 抽象类 ， 那么 就 没 必要 实现 该 接口 的 方法
__label__Java多态 __label__Java接口 在 实现 接口 的 时候 ， 也 要 注意 一些 规则 ：
__label__Java多态 __label__Java接口 一个 类 可以 同时 实现 多个 接口
__label__Java继承 __label__Java多态 __label__Java接口 一个 类 只能 继承 一个 类 ， 但是 能 实现 多个 接口
__label__Java继承 __label__Java多态 __label__Java接口 一个 接口 能 继承 另 一个 接口 ， 这和类 之间 的 继承 比较 相似
__label__Java继承 __label__Java多态 __label__Java接口 一个 接口 能 继承 另 一个 接口 ， 和 类 之间 的 继承 方式 比较 相似
__label__Java继承 __label__Java方法 __label__Java接口 接口的继承 使用 extends 关键字 ， 子 接口 继承 父 接口 的 方法
__label__Java继承 __label__Java多态 __label__Java接口 在 Java 中 ， 类 的 多 继承 是 不 合法 ， 但 接口 允许 多 继承
__label__Java继承 __label__Java多态 __label__Java接口 在 接口 的 多 继承 中 extends 关键字 只 需要 使用 一次 ， 在 其后 跟着 继承 接口
__label__Java接口 如下 所示 ：
__label__Java继承 __label__Java多态 __label__Java方法 __label__Java接口 以上 的 程序 片段 是 合法 定义 的 子 接口 ， 与 类 不同 的 是 ， 接口 允许 多 继承 ， 而   Sports 及     Event   可以 定义 或是 继承 相同 的 方法
__label__Java继承 __label__Java多态 __label__Java接口 __label__Java包(package) __label__Java方法 最 常用 的 继承 接口 是 没有 包含 任何 方法 的 接口
__label__Java方法 __label__Java接口 标记接口 是 没有 任何 方法 和 属性 的 接口 . 它 仅仅 表明 它 的 类 属于 一个 特定 的 类型 , 供 其他 代码 来 测试 允许 做 一些 事情
__label__Java接口 标记接口 作用 ： 简单 形象 的 说 就是 给 某个 对象 打个标 （ 盖个 戳 ） ， 使 对象 拥有 某个 或 某些 特权
__label__Java方法 __label__Java接口 没有 任何 方法 的 接口 被 称为 标记接口
__label__Java接口 标记接口 主要 用于 以下 两种 目的 ：
__label__Java接口 建立 一个 公共 的 父 接口 ： 正如 EventListener 接口 ， 这 是 由 几十个 其他 接口 扩展 的 Java   API ， 你 可以 使用 一个 标记接口 来 建立 一组 接口 的 父 接口
__label__Java多态 __label__Java方法 __label__Java接口 向 一个 类 添加 数据类型 ： 这种 情况 是 标记接口 最初 的 目的 ， 实现 标记接口 的 类 不 需要 定义 任何 接口 方法 ( 因为 标记接口 根本 就 没有 方法 ) ， 但是 该类 通过 多态性 变成 一个 接口类型
__label__Java继承 Java继承
__label__Java继承 __label__Java方法 继承 就是 子类 继承 父类 的 特征 和 行为 ， 使得 子类 对象 （ 实例 ） 具有 父类 的 实例 域 和 方法 ， 或 子类 从 父类 继承 方法 ， 使得 子类 具有 父类 相同 的 行为
__label__Java继承 兔子 和 羊 属于 食草动物 类 ， 狮子 和 豹 属于 食肉动物 类
__label__Java继承 食草动物 和 食肉动物 又 是 属于 动物类
__label__Java继承 所以 继承 需要 符合 的 关系 是 ： is - a ， 父类 更 通用 ， 子类 更 具体
__label__Java继承 虽然 食草动物 和 食肉动物 都 是 属于 动物 ， 但是 两者 的 属性 和 行为 上 有 差别 ， 所以 子类 会 具有 父类 的 一般 特性 也 会 具有 自身 的 特性
__label__Java继承 __label__Java关键字 在   Java   中 通过   extends   关键字 可以 申明 一个 类 是从 另外 一个 类 继承 而来 的 ， 一般 形式 如下 ：
__label__Java继承 需要 注意 的 是   Java   不 支持 多 继承 ， 但 支持 多重 继承
__label__Java继承 __label__Java方法 __label__访问控制修饰符 子类 拥有 父类 非   private   的 属性 、 方法
__label__Java继承 __label__Java方法 子类 可以 拥有 自己 的 属性 和 方法 ， 即 子类 可以 对 父类 进行 扩展
__label__Java继承 __label__Java方法 子类 可以 用 自己 的 方式 实现 父类 的 方法
__label__Java继承 Java   的 继承 是 单 继承 ， 但是 可以 多重 继承 ， 单 继承 就是 一个 子类 只能 继承 一个 父类 ， 多重 继承 就是 ， 例如   B   类 继承   A   类 ， C   类 继承   B   类 ， 所以 按照 关系 就是   B   类 是   C   类 的 父类 ， A   类 是   B   类 的 父类 ， 这是   Java   继承 区别 于   C++   继承 的 一个 特性
__label__Java继承 提高 了 类 之间 的 耦合 性 （ 继承 的 缺点 ， 耦合度 高 就 会 造成 代码 之间 的 联系 越 紧密 ， 代码 独立性 越差 ）
__label__Java继承 __label__Java包(package) __label__Java关键字 继承 可以 使用   extends   和   implements   这 两个 关键字 来 实现 继承 ， 而且 所有 的 类 都 是 继承 于   java . lang . Object ， 当 一个 类 没有 继承 的 两个 关键字 ， 则 默认 继承 object （ 这个 类 在   java . lang   包中 ， 所以 不 需要   import ） 祖先 类
__label__Java继承 在   Java   中 ， 类 的 继承 是 单一 继承 ， 也就是说 ， 一个 子类 只能 拥有 一个 父类 ， 所以   extends   只能 继承 一个 类
__label__Java继承 __label__Java多态 __label__Java接口 __label__Java关键字 使用   implements   关键字 可以 变相 的 使 java 具有 多 继承的特性 ， 使用 范围 为类 继承 接口 的 情况 ， 可以 同时 继承 多个 接口 （ 接口 跟 接口 之间 采用 逗号 分隔 ）
__label__Java继承 __label__重写(Override) __label__Java关键字 super 关键字 ： 我们 可以 通过 super 关键字 来 实现 对 父类 成员 的 访问 ， 用来 引用 当前 对象 的 父类
__label__Java继承 __label__Java关键字 this 关键字 ： 指向 自己 的 引用
__label__Java继承 __label__非访问修饰符 __label__Java包(package) __label__Java方法 __label__Java局部变量 final   可以 用来 修饰 变量 （ 包括 类 属性 、 对象 属性 、 局部变量 和 形参 ） 、 方法 （ 包括 类 方法 和 对象 方法 ） 和 类
__label__Java继承 __label__非访问修饰符 final   含义 为   " 最终 的 "
__label__Java继承 __label__非访问修饰符 __label__Java多态 __label__重写(Override) __label__Java方法 __label__Java关键字 使用   final   关键字 声明 类 ， 就是 把 类 定义 定义 为 最终 类 ， 不能 被 继承 ， 或者 用于 修饰 方法 ， 该 方法 不能 被子 类 重写 ：
__label__Java继承 __label__非访问修饰符 声明 类 ： final   class   类名   { / / 类体 }
__label__Java基础语法 __label__访问控制修饰符 __label__Java继承 __label__非访问修饰符 __label__Java方法 声明 方法 ： 修饰符 ( public / private / default / protected )   final   返回值 类型   方法 名 ( ) { / / 方法 体 }
__label__Java继承 __label__Java方法 __label__非访问修饰符 注 ：   final   定义 的 类 ， 其中 的 属性 、 方法 不是   final   的
__label__Java继承 __label__构造方法 __label__对象和类 子类 是 不 继承 父类 的 构造器 （ 构造方法 或者 构造函数 ） 的 ， 它 只是 调用 （ 隐式 或 显式 ）
__label__Java继承 __label__重写(Override) __label__Java关键字 如果 父类 的 构造器 带有 参数 ， 则 必须 在 子类 的 构造器 中显式 地 通过   super   关键字 调用 父类 的 构造器 并 配以 适当 的 参数 列表
__label__Java继承 __label__重写(Override) __label__Java关键字 如果 父类 构造器 没有 参数 ， 则 在 子类 的 构造器 中 不 需要 使用   super   关键字 调用 父类 构造器 ， 系统 会 自动 调用 父类 的 无参 构造器
__label__重写(Override) 重写(Override)
__label__重写(Override) __label__Java方法 __label__Java多态 重写 是 子类 对 父类 的 允许 访问 的 方法 的 实现 过程 进行 重新 编写 ,   返回值 和 形参 都 不能 改变
__label__重写(Override) __label__Java多态 即 外壳 不变 ， 核心 重写 ！
__label__重写(Override) __label__Java多态 重写 的 好处 在于 子类 可以 根据 需要 ， 定义 特定 于 自己 的 行为
__label__重写(Override) __label__Java方法 也就是说 子类 能够 根据 需要 实现 父类 的 方法
__label__Java异常 __label__重写(Override) __label__Java方法 __label__Java多态 重写 方法 不能 抛 出新 的 检查 异常 或者 比 被 重写 方法 申明 更加 宽泛 的 异常
__label__重写(Override) __label__Java方法 __label__Java多态 参数 列表 与 被 重写 方法 的 参数 列表 必须 完全相同
__label__重写(Override) __label__Java方法 __label__Java多态 返回 类型 与 被 重写 方法 的 返回 类型 可以 不 相同 ， 但是 必须 是 父类 返回值 的 派生类 （ java5   及 更 早 版本 返回 类型 要 一样 ， java7   及 更 高 版本 可以 不同 ）
__label__重写(Override) __label__Java方法 __label__Java多态 访问 权限 不能 比父 类 中 被 重写 的 方法 的 访问 权限 更 低
__label__重写(Override) __label__Java方法 __label__Java多态 父类 的 成员 方法 只能 被 它 的 子类 重写
__label__非访问修饰符 __label__Java继承 __label__Java多态 __label__重写(Override) __label__Java方法 声明 为   final   的 方法 不能 被 重写
__label__非访问修饰符 __label__重写(Override) __label__Java方法 __label__Java多态 声明 为   static   的 方法 不能 被 重写 ， 但是 能够 被 再次 声明
__label__访问控制修饰符 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__重写(Override) __label__Java方法 __label__Java包(package) 子类 和 父类 在 同一个 包中 ， 那么 子类 可以 重写 父类 所有 方法 ， 除了 声明 为   private   和   final   的 方法
__label__访问控制修饰符 __label__非访问修饰符 __label__Java继承 __label__Java多态 __label__重写(Override) __label__Java包(package) __label__Java方法 子类 和 父类 不 在 同一个 包中 ， 那么 子类 只 能够 重写 父类 的 声明 为   public   和   protected   的 非   final   方法
__label__Java异常 __label__重写(Override) __label__Java方法 __label__Java多态 重写 的 方法 能够 抛出 任何 非 强制 异常 ， 无论 被 重写 的 方法 是否 抛出 异常
__label__Java异常 __label__重写(Override) __label__Java方法 __label__Java多态 但是 ， 重写 的 方法 不能 抛 出新 的 强制性 异常 ， 或者 比 被 重写 方法 声明 的 更 广泛 的 强制性 异常 ， 反之 则 可以
__label__构造方法 __label__重写(Override) __label__对象和类 __label__Java多态 构造方法 不能 被 重写
__label__Java继承 __label__重写(Override) __label__Java方法 __label__Java多态 如果 不能 继承 一个 类 ， 则 不能 重写 该类 的 方法
__label__Java继承 __label__Java多态 __label__重写(Override) __label__Java方法 __label__Java关键字 当 需要 在 子类 中 调用 父类 的 被 重写 方法 时 ， 要 使用   super   关键字
__label__重载(Overload) 重载(Overload)
__label__Java方法 __label__重载(Overload) 重载 ( overloading )   是 在 一个 类 里面 ， 方法 名字 相同 ， 而 参数 不同
__label__重载(Overload) 返回 类型 可以 相同 也 可以 不同
__label__Java方法 __label__重载(Overload) 每个 重载 的 方法 （ 或者 构造函数 ） 都 必须 有 一个 独一无二 的 参数 类型 列表
__label__Java继承 __label__重载(Overload) 最 常用 的 地方 就是 构造器 的 重载
__label__重载(Overload) 重载 规则 :
__label__Java方法 __label__重载(Overload) 被 重载 的 方法 必须 改变 参数 列表 ( 参数 个数 或 类型 不 一样 ) ；
__label__Java方法 __label__重载(Overload) 被 重载 的 方法 可以 改变 返回 类型 ；
__label__Java方法 __label__Java基础语法 __label__重载(Overload) 被 重载 的 方法 可以 改变 访问修饰符 ；
__label__Java异常 __label__Java方法 __label__重载(Overload) 被 重载 的 方法 可以 声明 新 的 或 更 广 的 检查 异常 ；
__label__Java方法 __label__重载(Overload) 方法 能够 在 同一个 类中 或者 在 一个 子类 中 被 重载
__label__重载(Overload) 无法 以 返回值 类型 作为 重载 函数 的 区分 标准
__label__重写与重载之间的区别 重写与重载之间的区别
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__重写与重载之间的区别 区别 点   参数 列表   重载 方法   必须 修改   重写 方法   一定 不能 修改  
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__重写与重载之间的区别 区别 点   返回 类型   重载 方法   可以 修改   重写 方法   一定 不能 修改  
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__Java异常 __label__重写与重载之间的区别 区别 点   异常   重载 方法   可以 修改   重写 方法   可以 减少 或 删除 ， 一定 不能 抛 出新 的 或者 更广 的 异常  
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__重写与重载之间的区别 区别 点   访问   重载 方法   可以 修改   重写 方法   一定 不能 做 更 严格 的 限制 （ 可以 降低 限制 ）  
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__重写与重载之间的区别 方法 的 重写 ( Overriding ) 和 重载 ( Overload ing ) 是 java 多态性 的 不同 表现 ， 重写 是 父类 与 子类 之间 多态性 的 一种 表现 ， 重载 可以 理解 成 多态 的 具体 表现形式
__label__Java方法 __label__重写与重载之间的区别 __label__重载(Overload) ( 1 ) 方法 重载 是 一个 类中 定义 了 多个 方法 名 相同 , 而 他们 的 参数 的 数量 不同 或 数量 相同 而 类型 和 次序 不同 , 则 称为 方法 的 重载 ( Overload ing )
__label__重写(Override) __label__Java方法 __label__重写与重载之间的区别 __label__Java多态 ( 2 ) 方法 重写 是 在 子类 存在 方法 与 父类 的 方法 的 名字 相同 , 而且 参数 的 个数 与 类型 一样 , 返回值 也 一样 的 方法 , 就 称为 重写 ( Overriding )
__label__Java多态 __label__重写(Override) __label__Java方法 __label__重载(Overload) __label__重写与重载之间的区别 ( 3 ) 方法 重载 是 一个 类 的 多态性 表现 , 而 方法 重写 是 子类 与 父类 的 一种 多态性 表现
